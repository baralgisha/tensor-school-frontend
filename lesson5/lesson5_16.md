# События

## Виды событий

**Событие** – это определенный сигнал от браузера, который возникает в результате действий пользователя или других причин. Например: щелчок мыши, нажатие клавиши на клавиатуре, изменение размера области просмотра, завершение загрузки документа и т.д.

События в браузере (веб-события) являются частью стандарта DOM. Вот некоторые из них:

* **DOMContentLoaded** – завершение загрузки DOM;
* **click** – клик (нажатие левой кнопки мыши, на устройствах с сенсорным управлением возникает при касании);
* **keydown/keyup** – нажатие/отпускание клавиши на клавиатуре;
* **resize** – изменение размеров документа;
* **mousemove** – при движении мыши.

> Важно отметить, что веб-события не являются частью основного языка JavaScript.
> Они определены как часть JavaScript-API, встроенных в браузер.

Подробнее о видах событий можно посмотреть [Справочнике по событиям](https://developer.mozilla.org/ru/docs/Web/Events).

## Обработчики событий

Зачем нужны события? В коде JavaScript мы можем определить возникновение события и как-то его обработать. На каждое доступное событие можно назначить **обработчик событий** — блок кода, который будет запускаться при срабатывании события.

Есть несколько способов назначить событию обработчик:

* Использование атрибута HTML (не является хорошей практикой);
* Использование свойства DOM-объекта;
* Использование специального метода *addEventListener*.

Рассмотрим подробнее каждый из них и обсудим, какие из них следует использовать.

### Использование атрибута HTML

Это самый простой способ попробовать события в действии. Чтобы назначить, например, обработчик события *click*, используем атрибут *onclick*:

```html

<button type="button" onclick="alert('Привет!')">Кнопка</button>
```

Если нужно поместить в атрибут достаточно много кода, то можно его написать в виде функции, а в атрибуте просто вызвать эту функцию:

```html

<script>
    function myFunction() {
        for (let i = 1; i <= 3; i++) {
            alert("Сообщение номер " + i);
        }
    }
</script>
<button type="button" onclick="myFunction()">Кнопка</button>
```

Как видно, в примерах выше происходит смешивание HTML и JavaScript кода, поэтому задавать обработчик напрямую в разметке страницы не является хорошей практикой.

### Использование свойства DOM-объекта

Чтобы назначить обработчик события, можно взять у DOM-объекта свойство *onclick* и присвоить ему функцию. За счет этого HTML отделяется от JavaScript:

```html

<button id="myButton" type="button">Кнопка</button>
<script>
    const button = document.getElementById('myButton');

    button.onclick = function () {
        alert('Привет!');
    };
</script>
```

У этого способа есть недостаток, который заключается в том, что невозможно назначить одному событию несколько обработчиков, так как у DOM-объекта может быть только одно свойство с именем *onclick*.

Если в коде создать новый обработчик, то он перезапишет предыдущий:

```html

<button id="myButton" type="button">Кнопка</button>
<script>
    const button = document.getElementById('myButton');

    button.onclick = function () {
        alert('Привет!');
    };

    // заменит предыдущий обработчик
    button.onclick = function () {
        alert('Привет еще раз!');
    };
</script>
```

Убрать обработчик можно так:
```js
button.onclick = null
```

### Использование метода addEventListener

Еще один способ установки обработчиков событий представляет использование *слушателей* (от англ. event listeners), который имеет преимущества по сравнению с более старыми механизмами, рассмотренными ранее. Этот способ позволяет повесить множество обработчиков на один элемент.

Пример:

```html

<button id="myButton" type="button">Кнопка</button>
<script>
    const button = document.getElementById('myButton');

    button.addEventListener('click', () => alert('Привет!'));

    // Добавляем второй обработчик
    button.addEventListener('click', () => alert('Привет еще раз!'));
</script>
```

Каждый обработчик события представляет собой функцию, которая будет вызвана в момент наступления события. Обработчики вызываются один за другим, в том же порядке, в котором они были определены.

Синтаксис addEventListener:

```js
element.addEventListener(event, handler[, options]);
```

* **event** – имя события, например *"click"*;
* **handler** – ссылка на функцию-обработчик;
* **options** (не обязательный) – объект, в котором можно задать дополнительные параметры.

В **options** можно задать:

* **once** - если *true*, то обработчик будет вызван всего один раз;
* **capture** - задает фазу всплытия и перехвата, рассмотрим позже;
* **passive** - указывает, что обработчик никогда не вызовет *preventDefault()* - это также рассмотрим позже; если установить *true* - то обработчик никогда не вызовет этот метод, т.е. отмена действия по умолчанию не произойдет.

Убрать обработчик можно используя *removeEventListener*:

```js
element.removeEventListener(event, handler[, options]);
```

Этот метод принимает аргументы тех же типов, что *addEventListener*. При этом для того, чтобы убрать обработчик нужно указывать **точно такие же аргументы**, которые мы использовали при его назначении.

## Объект событий

Иногда внутри функции обработчика событий вы можете увидеть параметр, заданный с таким именем, как *event*, *evt* или просто *e*. Это специальный **объект события**, автоматически передающийся в обработчик. С помощью него можно узнать дополнительную информацию - подробности о том, что произошло.

> Не важно как назначен обработчик – он получает объект события первым аргументом.

Например, можно узнать координаты точки, в которой произошел клик:

```html

<button id="myButton" type="button">Кнопка</button>
<script>
    const button = document.getElementById('myButton');

    button.addEventListener('click', function (event) {
        // Координаты точки, в которой произошел клик
        console.log(event.clientX);
        console.log(event.clientY);
    });
</script>
```

Вот некоторые свойства объекта-события *Event*, которые чаще всего встречаются:

* **event.target** - элемент, на котором было вызвано событие;
* **event.currentTarget** - элемент, к которому прикреплен обработчик события;
* **event.type** - тип (имя) события;

У каждого типа событий свой набор свойств, подробнее о них смотрите в [документации](https://developer.mozilla.org/ru/docs/Web/API/Event).

### Действие по умолчанию

Для некоторых элементов браузер выполняет действие по умолчанию при срабатывании определенных событий. Например, клик по ссылке инициирует переход на новый URL. Зачастую такое действие браузера не нужно. С помощью метода *preventDefault()* объекта *Event* мы можем остановить дальнейшее выполнение события.

```html

<a href="/qwerty" id="myLink">Ссылка</a>
<script>
    const link = document.getElementById('myLink');

    link.addEventListener('click', function (event) {
        // Если этого не сделать, то браузер выполнит загрузку новой страницы /qwerty
        event.preventDefault();
    });
</script>
```

## Всплытие и Перехват

Когда мы инициируем событие нажатия, то это событие может распространяться от элемента к элементу. Например, если мы нажимаем на блок *div*, то также мы нажимаем и на элемент *body*, в котором блок *div* находится, и на *html*:

```html

<!-- При клике на div сработают все три события -->
<html onclick="alert('html')">
    <body onclick="alert('body')">
        <div onclick="alert('div')"></div>
    </body>
</html>
```

То есть происходит распространение события, оно является двунаправленным: от *Window* к целевому элементу и обратно. Также это распространение называют: **всплытие и погружение** или **всплытие и перехват**. Согласно стандарту [DOM Events](https://www.w3.org/TR/DOM-Level-3-Events/) оно делится на 3 фазы:

1. **Фаза погружения** (capturing) – событие сначала идет сверху вниз.
2. **Фаза цели** (target) – событие достигло целевого(исходного) элемента.
3. **Фаза всплытия** (bubbling) – событие начинает всплывать.

### Всплытие

Чтобы понять принцип всплытия, вернемся к предыдущему примеру. Клик по *div* вызовет обработчик *onclick*:

1. Сначала на самом *div*
2. Затем на *body*
3. Затем на самом *html*
4. И так далее вверх по цепочке до *document* и затем до *Window*.

![Bubbling](bubbling.svg)

Можно сказать, что это похоже на то, как всплывает пузырек воздуха в воде. Именно эта стадия подразумевается при вызове *addEventListener* без указания третьего параметра:

```js
elem.addEventListener(event, handler)
```

По умолчанию почти все события всплывают. Но существуют события, которые не всплывают, например *focus/blur*, *load/unload*, ...

Подобное поведение (всплытие) не всегда является желательным. И в этом случае мы можем остановить распространение события с помощью методов объекта *event*:

* **event.stopPropagation()** - предотвращает всплытие, но на текущем элементе все обработчики будут вызваны.
* **event.stopImmediatePropagation()** - предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

Пример использования:

```html

<div id="myDiv">Ссылка</div>

<script>
    const myDiv = document.getElementById("myDiv");
    myDiv.addEventListener("click", function (event) {
        console.log("Событие на myDiv");
        event.stopPropagation();
    });
</script>
```

> Не стоит применять **event.stopPropagation** и **event.stopImmediatePropagation** без явной нужды, зачастую это событие может понадобиться.

### Перехват

Перехват (погружение) довольно редко используется в разработке, но в некоторых сценариях может быть полезно. Чтобы поймать событие на стадии погружения, нужно у метода *addEventListener* в третьем аргументе *options* задать *capture*:

```js
elem.addEventListener(event, handler, {capture: true})

// или просто "true", как сокращение для {capture: true}
elem.addEventListener(event, handler, true)
```

Этот аргумент задает фазу, на которой нужно отлавливать событие.

## Делегирование

Делегирование - это прием для работы с DOM, который основан на принципе всплытия событий. Прием полезен в случае, когда есть много DOM-элементов, обработка событий на которых которых очень схожа, и чтобы не добавлять обработчик к каждому элементу, можно сделать это только для одного общего родительского элемента.

Разберем на примере как "выглядит" делегирование. Допустим, есть список:

```html

<ul id="list">
    <li>Один</li>
    <li>Два</li>
    <li>Три</li>
</ul>
```

Допустим, нужно обработать клик на каждый *li*, например, вывести сообщение. Добавление отдельного обработчика для каждого элемента списка не самое лучшее решение. А что если элементы списка добавляются динамически? А если их будет не три, а намного больше?

Данную задачу можно решить с помощью делегирования. Алгоритм следующий:
1. Вешаем обработчик на контейнер *ul*.
2. В обработчике проверяем исходный элемент *event.target*.
3. Если событие произошло внутри нужного нам элемента, то обрабатываем его.

```js
document.querySelector('#list').addEventListener('click', function (event) {
   if (event.target && event.target.nodeName === 'LI') {
      alert(event.target.innerHTML);
   }
});
```

Итого мы получаем следующие преимущества:
* Не нужно вешать много обработчиков, а значит экономим память.
* Не нужно ставить или снимать много обработчиков, а значит будет меньше кода.