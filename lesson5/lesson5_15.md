# Работа с DOM

## Окружение

В данном уроке мы рассмотрим, как JavaScript может работать с html-документом.
Сам по себе JavaScript, как язык, не предусматривает никаких методов для работы с браузером и вообще не знает об html.
Как же тогда встроенный в браузер JavaScript взаимодействует с html-документом?
Для языка JavaScript браузер предоставляет свое окружение. Давайте взглянем на блок-схему:

![Window](windowObjects.svg)

Схема показывает, что доступно для JavaScript'a в браузерном окружении. Прежде всего - это глобальный объект Window, который включает в себя такие понятия как DOM, BOM, а также интерпретатор JavaScript. Именно глобальный объект Window, к которому у JavaScript'а есть доступ, позволяет нам работать с окном браузера, а следовательно и с html-документом.

## BOM

BOM - Browser Object Model. Это дополнительные (дочерние для Window) объекты, предоставляемые браузером(окружением) для работы с чем угодно, кроме документа. Не существует каких-либо официальных стандартов для BOM. Чтобы стандартизировать эти фундаментальные аспекты JavaScript, консорциум W3C определил основные BOM-элементы в спецификации HTML5 - https://html.spec.whatwg.org/.

BOM-объекты обеспечивают доступ к функционалу браузера. Например: 
* Объект **navigator** - для работы с версией браузера.
* Объект **location** - для работы с адресами.
* Объект **screen** - информация об экране пользователя.
* Функции **alert/confirm/prompt** - методы объекта окна браузера для коммуникации с пользователем, выводят диалоговые окна.
* ...

## DOM

DOM - Document Object Model. Представляет собой все содержимое html-документа в виде дерева объектов, с которыми можно взаимодействовать. Мы уже знаем, что основой любого html-документа являются теги и в соответствии с DOM каждый тег является объектом. Текст а также комментарии также являются объектами. Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.

Познакомиться со структурой DOM, начнем с простого html-документа:
```html
<html>
    <head>
      <title>html-документ</title>
    </head>
    <body>
        <h1>Привет</h1>
        <p>Текст...</p>
        <!-- комментарий -->
        <p>Полный абзац</p>
    </body>
</html>
```

Все что написано в html-документе: каждый тег, текст, комментарий является частью DOM, их также называют узлами. Существует 12 типов узлов, о них можно узнать в спецификации DOM - https://dom.spec.whatwg.org/

## Типы узлов

На практике чаще всего используется 4 типа узлов:

* **document** – «входная точка» в DOM, все операции с DOM начинаются с этого объекта.
* **узлы-элементы** – HTML-теги, основные строительные блоки.
* **текстовые узлы** – содержат текст.
* **узлы-комментарии** – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM.

## Навигация

Самые верхние узлы DOM-дерева доступны через JavaScript как свойства объекта document:

```js
document.documentElement; // DOM-узел, соответствует тегу html
document.head; // DOM-узел, соответствует тегу head
document.body; // DOM-узел, соответствует тегу body
```

Рассмотрим подробнее навигацию между узлами DOM-дерева. Узлы в дереве имеют иерархические отношения друг с другом. Термины "родитель", "потомок" и "брат или сестра" используются для описания отношений. 
На рисунке ниже изображены основные методы навигации:

![DOM](domLinks.svg)

Как видно, можно использовать следующие свойства для перехода между узлами с помощью JavaScript:

* **parentNode** - объект, возвращает родителя.
* **childNodes** - коллекция, возвращает список всех детей, включая текстовые узлы. 
  
> Коллекция (HTMLCollection) – особый перебираемый объект-псевдомассив.
> 
> **HTMLCollection НЕ является массивом!**
> 
> Можно перемещаться по списку и ссылаться на элементы с помощью числа (как в массиве). Однако нельзя использовать методы массива, такие как valueOf(), pop(), push(), или join() в HTMLCollection.

* **firstChild** - объект, возвращает первый дочерний узел.
* **lastChild** - объект, возвращает последний дочерний узел.
* **previousSibling** - объект, возвращает предыдущий узел того же родителя (предыдущий сосед).
* **nextSibling** - объект, возвращает следующий узел того же родителя (следующий сосед).

Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в childNodes находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть. Но чаще всего требуется оперировать только узлами-элементами, т.е. тегами. Поэтому для навигации только между узлами-элементами по аналогии используются следующие свойства: **parentElement**, **children**, **firstElementChild**, **lastElementChild**, **previousElementSibling**, **nextElementSibling**.

## Поиск узлов

Свойства навигации по DOM-дереву удобны, когда мы хотим получить объект, который находится рядом. В остальных случаях для получения произвольного элемента(ов) на странице существует несколько основных способов:


### querySelector
```js
elem.querySelector('ul > li');
```
Возвращает первый элемент, соответствующий данному CSS-селектору.


### querySelectorAll
```js
elem.querySelectorAll('ul > li');
```
Возвращает все элементы внутри elem, удовлетворяющие данному CSS-селектору.


### getElementById
```js
document.getElementById('elem');
```
Возвращает один элемент с указанным id или null, можно вызвать только для объекта document.


### getElementsByName
```js
document.getElementsByName('attrName');
```
Возвращает элементы с заданным значением атрибута name.


### getElementsByTagName
```js
elem.getElementsByTagName('div');
```
Возвращает элементы с данным тегом и возвращает их коллекцию. Передав «*» вместо тега, можно получить всех потомков.


### getElementsByClassName
```js
elem.getElementsByClassName('className');
```
Возвращает элементы, которые имеют данный CSS-класс.


### closest
```js
elem.closest('.parent');
```
Ищет ближайшего предка, который соответствует CSS-селектору


### matches
```js
elem.matches('.active');
```
Проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.


##  Атрибуты и свойства

Как известно у html-тегов могут быть заданы различные атрибуты, а DOM-элементы могут быть наделены различными свойствами. При загрузке страницы браузер «считывает» HTML-теги и атрибуты и генерирует из них DOM-объекты и свойства.

> **Атрибуты** – это то, что написано в HTML.
> **Свойства** – это то, что находится в DOM-объектах.

Так же как и для обычных объектов JavaScript мы можем создавать и удалять для DOM-объектов свойства и методы:
```js
document.body.helloWorld = 'Hello World'; // создали новое свойство для body

document.body.sayHelloWorld = () => { alert('Hello World'); }; // создали новый метод для body
```

Как было сказано ранее, браузер создает из атрибутов DOM-свойства. Таким образом, когда у элемента есть id или другой стандартный атрибут, создается соответствующее свойство. Но этого не происходит, если атрибут нестандартный. Стоит отметить, что стандартный атрибут для одного тега может быть нестандартным для другого.

Таким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств, но способ получить значения атрибутов все равно есть! Вот они:

* **elem.hasAttribute(name)** – проверяет наличие атрибута.
* **elem.getAttribute(name)** – получает значение атрибута..
* **elem.setAttribute(name, value)**  – устанавливает значение атрибута.
* **elem.removeAttribute(name)** – удаляет атрибут.

Стоит отдельно отметить, что существуют атрибуты вида **data-***. Они позволяют хранить дополнительную информацию в стандартных элементах HTML. Их также называют data-атрибутами.

Для чтения data-атрибутов можно использовать метод getAttribute() с параметром, равным полному имени атрибута. Но есть и более простой способ, используя объект dataset.

> Все атрибуты, начинающиеся с префикса «data-», доступны в свойстве dataset.

Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.
Атрибуты, состоящие из нескольких слов, к примеру "data-about-elephant", становятся свойствами, записанными с помощью «верблюжьей» нотации: dataset.aboutElephant.

Пример:
```html
<body data-about="Animals" data-about-elephant="Elephant Jimmy">
    <script>
        alert(document.body.dataset.about); // Animals
        alert(document.body.dataset.aboutElephant); // Elephant Jimmy
    </script>
</body>
```

### Полезные свойства

Если необходимо узнать какой тег у DOM-объекта, мы можем это определить с помощью свойста **tagName**.
Также довольно часто нам нужно объект скрыть либо показать, для это мы можем использовать свойство **hidden**.
Свойство **textContent** позволяет получить только текстовые элементы, без тегов.

```html
<body>
    <div id="test">Тестовый документ</div>
    <script>
        // Получаем тег элемента
        alert(document.getElementById("test").tagName); // "DIV"
        
        // Скрыть/показать элемент
        document.getElementById("test").hidden = true
        alert(document.getElementById("test").hidden); // true
    </script>
</body>
```

Различных свойств у DOM-объектов существует гораздо больше, мы рассмотрели лишь некоторые из них.

##  Добавление и удаление узлов

Рассмотрим как создавать и изменять HTML-код страницы с помощью JavaScript. В этом нам помогут специальные методы и свойства. 

### Создание узлов

Создать новый элемент с заданным тегом и наполнить его текстом можно следующим образом:

```js
var div = document.createElement("div"); // создали узел-элемент
div.innerHTML = '<p>Текст<p>'; // вставили в <div> тег <p> с текстом
```

Создать новый текстовый узел с заданным текстом:
```js
var text = document.createTextNode("Это текст"); // создали текстовый-узел
```

Все эти созданные объекты сейчас находятся в переменных и не являются частью документа. Чтобы их туда вставить, в JavaScript существуют различные методы, разберем их далее.

### Вставка узлов

Вставлять новые объекты в HTML-документ можно по-разному, для этого есть методы: **append**,**prepend**, **before**, **after**, **replaceWith**.

Рассмотрим простой пример:

```html
<ol>
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
    var ol = document.getElementsByTagName("ol")[0] // выбрали тег 
    ol.before('before'); // вставить строку "before" перед <ol>
    ol.after('after'); // вставить строку "after" после <ol>
    ol.prepend('prepend'); // вставить строку "prepend" в начало <ol>
    ol.append('append'); // вставить строку "append" в конец <ol>
    ol.replaceWith('text'); // заменяет <ol> текстом
</script>
```

Наглядная иллюстрация того, куда эти методы вставляют:

![Append](beforePrependAppendAfter.svg)

Эти методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов. Строка с HTML-тегами будет вставлена как строка. Но как вставить вставить строку с HTML-тегами как это делает innerHTML? Для этого есть более универсальные метод **insertAdjacentHTML**.

Рассмотрим аналогичный предыдущему пример:

```html
<ol>
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
    var ol = document.getElementsByTagName("ol")[0] // выбрали тег 
    ol.insertAdjacentHTML('beforebegin', '<p>Строка</p>'); // вставить строку перед <ol>
    ol.insertAdjacentHTML('afterbegin', '<p>Строка</p>'); // вставить строку в начало <ol>
    ol.insertAdjacentHTML('beforeend', '<p>Строка</p>'); // вставить строку в конец <ol>
    ol.insertAdjacentHTML('afterend', '<p>Строка</p>'); // вставить строку после <ol>
</script>
```

Таким образом, мы можем вставить произвольный HTML в любое место страницы.
Стоит отметить, что наряду с **insertAdjacentHTML** есть также методы:

* **insertAdjacentText(where, text)** - text вставляется «как текст».  
* **insertAdjacentElement(where, elem)** - вставляет элемент.

Они редко используются.

### Удаление узлов

Для удаления узла используйте метод **node.remove()**.
Если нужно всего лишь переместить элемент в другое место – можно использовать методы вставки.

> Все методы вставки автоматически удаляют узлы со старых мест.

Разберем на примере:

```html
<div id="first">Первый</div>
<div id="second">Второй</div>
<script>
    // нет необходимости вызывать метод remove
    second.after(first); // берет #second и после него вставляет #first
</script>
```

### Клонирование узлов

Если необходимо склонировать элемент, используйте метод **cloneNode**.

Варианты вызова:

* **elem.cloneNode()**, либо **elem.cloneNode(false)** - клон будет без дочерних элементов
* **elem.cloneNode(true)** - «глубокий» клон элемента – со всеми атрибутами и дочерними элементами.

### Устаревшие методы

Есть другие методоы вставки и удаления, они в основном встречается в старых скриптах.
Подробно останавливаться на них не будем, просто перечислим их тут:

* **appendChild**
* **insertBefore**
* **replaceChild**
* **removeChild**
* **document.write**