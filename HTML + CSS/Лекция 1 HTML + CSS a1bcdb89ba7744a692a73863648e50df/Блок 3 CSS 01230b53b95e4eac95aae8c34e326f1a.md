# Блок 3. CSS

CSS (cascading style sheets) или каскадные таблицы стилей - язык таблиц стилей. Он позволяет описать визуальное отображение страницы гораздо более гибко и сильно, нежели ограниченный набор тегов HTML.

CSS-файл представляет собой набор правил, по которым будет отображена страница. Правила применяются к селектору (это может быть сам тег, класс, идентификатор или какой-то другой атрибут HTML-тега). 

Для начала рассмотрим примеры подключения CSS к HTML-документу. 

1. **Подключение через тег <link>** внутри <head>. Именно так мы подключали стили в предыдущем блоке. Здесь мы подключаем файл main.css, который лежит в папке styles относительно файла HTML-документа:

    ```html
    <html lang="en">
    <head>
    	<link rel="stylesheet" href="styles/main.css">
    </head>
    <body>
    </body> 
    ```

2. **Тег <style>**. Стили так же можно задавать в самом HTML-документе, без подключения файлов:

    ```html
    <html lang="en">
    <head>
    	<style>
    		.block {
    			margin-left: 12px;
    		}
    	</style>
    </head>
    <body>
    	<main class="block"></main>
    </body> 
    ```

3. Атрибут style. Стили задаются для конкретного элемента в HTML- документе:

    ```html
    <body>
    	<main style="border: 5px solid red; padding: 20px;"></main>
    </body> 
    ```

Рассмотрим небольшой пример:

![%D0%91%D0%BB%D0%BE%D0%BA%203%20CSS%2001230b53b95e4eac95aae8c34e326f1a/Untitled.png](%D0%91%D0%BB%D0%BE%D0%BA%203%20CSS%2001230b53b95e4eac95aae8c34e326f1a/Untitled.png)

В данном случае ко всем заголовкам h1 на всех страницах применится свойство font-family со значением Arial и свойство color со значением grey. 

### Виды селекторов

1. Универсальный селектор. Соответствует любому элементу.

```css
* {
	font-family: Comic Sans MS;
}
```

2. Селектор элемента. Применяются к элементу документа (тегу).

```css
span {
	font-family: Comic Sans MS;
}
```

3. Селектор класса. Позволяет задавать стили для всех элементов с атрибутом class. Класс никак не связан с тегом. 

```css
.class-name {
	font-family: Comic Sans MS;
}
```

Если элемент имеет несколько атрибутов класса, их значения объединяются с пробелами.

```html
<span class="first-class second-class my-class">Text</span>
```

4. Селектор идентификатора. Выборка осуществляется по атрибуту id. Такой атрибут согласно спецификации должен быть уникален в рамках страницы.

```css
#my_element {
	font-family: Comic Sans MS;
}
```

```html
<span id="my_element">Text</span>
```

5. Селекторы потомков. Применяют стили к элементам, расположенным внутри контейнера. 

```css
.my-class span {
	font-family: Comic Sans MS;
}
```

Стили будут применены ко всем элементам span, который находятся внутри элементов с классом .my-class. Именно так браузер и читает стили, справа налево. Именно поэтому не стоит злоупотреблять подобными селекторами. Лучше каждому span задать свой класс. С именованием классов помогают методологии, например БЭМ. О нём мы поговорим чуть позже.

Важным элементом этого селектора является пробел между классом и тегом. Если писать без него, то стили будут применены ко всем элементам span с классом my-class.

```css
span.my-class {
	font-family: Comic Sans MS;
}
```

6. Дочерний селектор. Описанные выше стили будут применяться ко всем элементам с классом .my-class внутри каждого <span>. Чтобы применить стили только к прямым потомкам (дочерним узлам), используют символ >

```css
span > .my-class {
	font-family: Comic Sans MS;
}
```

Такой стиль будет применен только ко всем прямым потомкам span'ам внутри .my-class.

7. Селекторы "соседей". CSS позволяет выбирать элемента на одном уровне.

```css
/* Выберет все p, что следуют сразу за h1 */
h1 + p {
	 margin-top: 20px
}

/* Выберет все p, что находятся на одном уровне c 
   h1 идущие сразу после него */
h1 ~ p {
	 margin-top: 20px
}
```

8. Селекторы атрибута. 

```css
/* Все элементы с атрибутом src */
[src] {
	font-family: Comic Sans MS;
}

/* Все элементы с атрибутом name равным form */
[name="form"] {
	font-family: Comic Sans MS;
}

/* Все элементы с атрибутом name которого содержит form */
[name~="form"] {
	font-family: Comic Sans MS;
}

/* Все элементы с атрибутом name которого начинается с form */
[name^="form"] {
	font-family: Comic Sans MS;
}

/* Все элементы с атрибутом name которого заканчивается на form */
[name$="form"] {
	font-family: Comic Sans MS;
}
```

### Псевдоклассы и псевдоэлементы

**Псевдоклассы** — это классы, фактически не прикрепленные к HTML-тегам. Они позволяют применить CSS-правила к элементам при совершении события или подчиняющимся определенному правилу.

Псевдоклассы характеризуют элементы со следующими свойствами:

- :link — не посещенная ссылка;
- :visited — посещенная ссылка;
- :hover — любой элемент, по которому проводят курсором мыши;
- :focus — интерактивный элемент, к которому перешли с помощью клавиатуры или активировали посредством мыши;
- :active — элемент, который был активизирован пользователем;
- :valid — поля формы, содержимое которых прошло проверку в браузере на соответствие указанному типу данных;
- :invalid — поля формы, содержимое которых не соответствует указанному типу данных;
- :enabled — все активные поля форм;
- :disabled — заблокированные поля форм, т.е., находящиеся в неактивном состоянии;
- :in-range — поля формы, значения которых находятся в заданном диапазоне;
- :out-of-range — поля формы, значения которых не входят в установленный диапазон;
- :lang() — элементы с текстом на указанном языке;
- :not(селектор) — элементы, которые не содержат указанный селектор — класс, идентификатор, название или тип поля формы — ;

    :not([type="submit"])

- :target — элемент с символом #, на который ссылаются в документе;
- :checked — выделенные (выбранные пользователем) элементы формы.

Так же существуют группы структурных псевдоклассов и структурных псевдоклассов типа, которые позволяют применять стили к определенным дочерним элементам, исходя из их порядка.

- :nth-child(odd) — нечётные дочерние элементы;
- :nth-child(even) — чётные дочерние элементы;
- :nth-child(3n) — каждый третий элемент среди дочерних;
- :nth-child(3n+2) — выбирает каждый третий элемент, начиная со второго дочернего элемента (+2)
- :nth-child(n+2) — выбирает все элементы, начиная со второго;
- :nth-child(3) — выбирает третий дочерний элемент;
- :nth-last-child() — в списке дочерних элементов выбирает элемент с указанным местоположением, аналогично с , но начиная с последнего, в обратную сторону :nth-child()
- :first-child — позволяет оформить только самый первый дочерний элемент тега;
- :last-child — позволяет форматировать последний дочерний элемент тега;
- :only-child — выбирает элемент, являющийся единственным дочерним элементом;
- :empty — выбирает элементы, у которых нет дочерних элементов;
- :root — выбирает элемент, являющийся корневым в документе — элемент html
- :nth-of-type() — выбирает элементы по аналогии с , при этом берёт во внимание только тип элемента :nth-child()
- :first-of-type — выбирает первый дочерний элемент данного типа;
- :last-of-type — выбирает последний элемент данного типа;
- :nth-last-of-type() — выбирает элемент заданного типа в списке элементов в соответствии с указанным местоположением, начиная с конца;
- :only-of-type — выбирает единственный элемент указанного типа среди дочерних элементов родительского элемента.

**Псевдоэлементы** - это части документа, которые не являются частью документа. Они недоступны из js. Обычно их используют для дополнительной стилизации, чтобы не засорять вёрстку.

- :first-letter — выбирает первую букву каждого абзаца, применяется только к блочным элементам;
- :first-line — выбирает первую строку текста элемента, применяется только к блочным элементам;
- :before — вставляет генерируемое содержимое перед элементом;
- :after — добавляет генерируемое содержимое после элемента.

Для :after и :before необходимо задавать свойство content, иначе они не будут отображены. Значение может быть пустым.

### Наследование и каскад

**Наследование** заключается в том, что элементы наследуют свойства своего родителя. Наследуются только свойства, относящие к текстовому содержимому страницы. Форматирование не наследуются.

Можно принудительно заставить элемент наследовать значение свойства своего родителя задав ему вместо значение ключевое слово inherit.

**Каскад** проявляется в том, как разные виды таблиц стилей применяются к документу, и как конфликтующие правила переопределяют друг друга.

У каждого правила в CSS есть свой вес. Переопределить поведение можно задав ключевого слова !important.

```css
div {
   background-color: transparent !important;
}
```

В остальном случае используются следующие параметры специфичности:

- для `id` добавляется `0, 1, 0, 0`
- для `class` добавляется `0, 0, 1, 0`
- для каждого элемента и псевдоэлемента добавляется `0, 1, 0, 0`
- для встроенного стиля, добавленного непосредственно к элементу через атрибут style — `0, 1, 0, 0`
- универсальный селектор не имеет специфичности

Специфичность селекторов суммируется и в результате будет применён стиль с наибольшим значением специфичности, либо тот, что был подключён последним.