# Оптимизация рендеринга
Рендеринг - это процесс превращения HTML и CSS в пиксели.

## Из чего состоит рендеринг
В общем случае, отрисовка каждого кадра состоит из пяти шагов:
1. **Выполнение JavaScript.** Любая работа JavaScript - обработка событий, таймеров, изменение содержимого страницы.
2. **Расчёт стилей (style).** Вычисление стилей для каждого элемента.
3. **Раскладка элементов (layout).** Вычисление размеров и расположения элементов.
4. **Отрисовка слоёв (paint).** В целях оптимизации, элементы рисуются на нескольких слоях. Например, всплывающие окна рисуются на отдельных слоях, чтобы при изменении окна не пересчитывались стили для всей страницы.
5. **Композиция (composite).** После того как слои нарисованы, браузер раскладывает их на странице в правильном порядке.

![Rendering pipeline](images/rendering-pipeline.jpg)

Некоторые шаги могут быть пропущены, если браузер посчитает, что они не нужны. Например, при изменении цвета текста нет никакого смысла пересчитывать расположение элементов.

Порядок этих шагов может быть нарушен, но обычно это приводит к замедлению.

## Не заставляйте браузер делать style/layout
Если JavaScript-код получает информацию об элементе (цвет, размер и т.п.), браузер попытается не вычислять их заново, а отдать уже готовую информацию, оставшуюся от предыдущего кадра.

Также, если в коде изменяются стили элемента, браузер не будет вычислять их сразу же, а подождёт до конца выполнения кода. Ему дешевле посчитать все изменения пачкой, потому что их может быть много.

Разработчик может вмешаться в эту схему, сначала изменив свойство, а потом прочитав его. В этом случае браузер будет вынужден рассчитать новую информацию об элементе прямо во время выполнения JavaScript-кода. Такое вмешательство называется _принудительный синхронный перерасчёт макета_ (_forced reflow_ или _forced synchronous layout_).

```js
element.style('height', 500);
console.log(element.style('height'));
```

Особенно сильно эта проблема проявляется, когда мы выполняем какие-то действия в цикле:

```js
const elements = document.querySelectorAll('.list-item');
for (let i = 0; i < elements.length; i++) {
    elements[i].style('height', 300);
    console.log(elements[i].clientHeight);
}
```

Здесь браузер вынужден пересчитывать информацию на каждом шаге цикла. Значительно дешевле сделать два цикла: первый будет менять высоту, а второй будет выводить её:

```js
const elements = document.querySelectorAll('.list-item');
for (let i = 0; i < elements.length; i++) {
    elements[i].style('height', 300);
}

for (let i = 0; i < elements.length; i++) {
    console.log(elements[i].clientHeight);
}
```

В данном случае браузер будет пересчитывать размеры элементов только один раз.

## Снижайте сложность отрисовки
Т.к. браузер перерисовывает слой только если на нём что-то изменилось, то можно ускорить страницу с помощью выноса элемента на отдельный слой. Так можно значительно уменьшить количество элементов, обрабатываемых браузером.

Вынести элемент на отдельный слой можно с помощью свойства [`will-change`](https://developer.mozilla.org/en-US/docs/Web/CSS/will-change). Например, если у нас есть элемент, который может двигаться, можно добавить в CSS следующее:

```css
.moving-element {
    will-change: transform;
}
```

`will-change` является _подсказкой_, он не обязывает браузер создавать новый слой. Браузер может посчитать, что ему дешевле перерисовать всё, чем создавать лишний слой.

Слои не являются бесплатными, браузеру нужно выделять под них память и заниматься их управлением, поэтому при проведении подобных оптимизаций всегда нужно профилировать.

## Используйте свойства, вызывающие только композицию
Самый быстрый код - код, который вообще не выполняется. Изменение некоторых CSS-свойств позволяет выполнять только пропускать отрисовку или раскладку элементов, а иногда и оба шага.

Примером таких свойств являются `transform` или `opacity`. Оба эти свойства позволяют браузеру пропускать отрисовку и раскладку.

> Для пропуска шагов элемент обязательно должен находиться на отдельном слое. Добиться этого можно с помощью свойства `will-change`.

### Дополнительные материалы
[Цикл статей по оптимизации от Google](https://developers.google.com/web/fundamentals/performance/rendering)
[Список свойств, изменение которых приведёт к перерасчёту макета](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)