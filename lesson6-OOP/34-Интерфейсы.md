# Интерфейсы

В JavaScript основной способ группировки и передачи данных - это объекты. В TypeScript такие объекты представлены псевдонимами и интерфейсами. В [актуальной версии документации](https://www.typescriptlang.org/docs/handbook/2/objects.html) они называются Object Types 

Передаваемые объекты могут быть анонимными
```TypeScript
function greet(person: { name: string; age: number }) {
    return "Hello " + person.name;
}
```

Определены через псевдоним
```TypeScript
type Person = {
    name: string;
    age: number;
};

function greet(person: Person) {
    return "Hello " + person.name;
}
```

Или интерфейс
```TypeScript
interface Person {
    name: string;
    age: number;
}

function greet(person: Person) {
    return "Hello " + person.name;
}
```

Во всех трех приведенных выше примерах мы написали функции, которые принимают объекты, содержащие свойство `name`(которое должно быть `string`) и `age`(которое должно быть `number`).

Результат компиляции для всех трех вариантов будет идентичен
```JavaScript
function greet(person) {
    return "Hello " + person.name;
}
```
Как видно из результата компиляции, передаваемая типизация является "синтаксическим сахаром", т.е. никак не влияет на итоговый результат.

При этом использование псевдонимов и интерфейсов в корректно настроенной IDE позволяет существенно сэкономить время на поиске опечаток в сложных комплексных параметрах и на дальнейшей поддержке кода делая его значительно более читаемым.

_Тема интерфейсов довольно обширна, поэтому далее мы сосредоточимся на наиболее распространенных в кодовой базе Компании "Тензор" конструкциях. Прочие примеры можно найти в [документации](https://www.typescriptlang.org/docs/handbook/2/objects.html)_

## Опциональные свойства
Большую часть времени мы будем иметь дело с объектами, которые **могут** иметь набор свойств. В таких случаях мы можем пометить эти свойства как необязательные, добавив вопросительный знак `?` в конце их имен.
```TypeScript
interface PaintOptions {
    shape: Shape;
    xPos?: number;
    yPos?: number;
}

function paintShape(opts: PaintOptions) {
    // ...
}

const shape = getShape();
paintShape({ shape });
paintShape({ shape, xPos: 100 });
paintShape({ shape, yPos: 100 });
paintShape({ shape, xPos: 100, yPos: 100 });
```
В этом примере xPos и yPos являются необязательными. Поэтому все вызовы `paintShape` в этом примере валидны.

## Индексы

Иногда вы не знаете заранее все имена свойств типа, но знаете структуру

В этих случаях вы можете использовать индексы для описания типов возможных значений
```TypeScript
interface StringArray {
  [index: number]: string;
}
 
const myArray: StringArray = {0: 'a', 1: 'b', 2: 'c', 3: 'd'};
const secondItem = myArray[1]; // b
```

## Обобщения

Предположим у нас есть интерфейс `Box` - некая "коробочка" в которую мы можем положить что угодно.
Исходя из описания мы можем описать интерфейс так
```TypeScript
interface Box {
    contents: any;
}
```
Или так
```TypeScript
interface Box {
    contents: unknown;
}
```
Оба варианта будут правильными и с ними можно работать.

Теперь предположим, что при работе с этим интерфейсом у нас появилось несколько стабильных типов содержимого.
Тогда мы можем добавить новые интерфейсы
```TypeScript
interface NumberBox {
  contents: number;
}
 
interface StringBox {
  contents: string;
}
 
interface BooleanBox {
  contents: boolean;
}
```

Или сделать класс `Box` обобщенным с тем же результатом
```TypeScript
interface Box<T> {
  contents: T;
}
 
const unkownBox: Box<unknown> = {contents: {data: 'unknown data'}};
const anyBox: Box<any> = {contents: undefined};
const numberBox: Box<number> = {contents: 1};
const stringBox: Box<string> = {contents: '1'};
const boolBox: Box<boolean> = {contents: true};
```