# Функции

Нередко оказывается необходимым повторять набор одних и тех же действий во многих частях программы.
Для того, чтобы не дублировать код во многих местах, были придуманы функции. 
Функция – это именованный фрагмент кода, к которому можно обратиться в нужных местах программы по имени. 
Существует множество уже готовых функций, которые предоставляет JavaScript и, конечно, мы также всегда можем написать свои собственные функции.

Функции являются основными «строительными блоками» программы. 
Любая функция может иметь ряд входных параметров и может вернуть результат.
Упрощая, работу функции можно свести к следующей схеме:

![Функция](lesson5_13.png)

Однако в реальности функции могут также производить "побочный эффект" - например, изменять глобальные переменные, взаимодействовать с пользователем, сохранять данные и т.д.

## Создание функции

Для создания функций мы можем использовать объявление функции. 

Объявление функции включает в себя:
- Имя функции,
- Список параметров, принимаемых функцией, заключённых в круглые скобки и разделённых запятыми,
- Инструкции, которые будут выполнены после вызова функции, заключают в фигурные скобки.


```javascript
/**
 * Комментарий к функции с описанием ее работы
 * Назначение функции
 * @param {*} Параметры функции и их тип
 * @return Результат работы
 */
function имя([параметры]) {
    // Тело функции
    [return результат;]
}
```

Рассмотрим эти моменты чуть подробнее.


### Название функции

Существуют как формальные, так и неформальные требования к именованию функции.

Формальные требования сводятся к тому, что имя функции должно соответствовать тем же условиям, которые существуют для именования переменных (см. соответствующий [раздел](https://pro-edu.tensor.ru/tensor/lesson/page.php?id=3166&sectionid=4&pageid=4)).

К неформальным требованием можно отнести соглашение, что *название функции должно четко и ясно описывать, что именно делает функция*. 
Например, если функция очищает ячейку таблицы, то логично дать ей название в стиле clearCell(), emptyСell() или removeDataFromCell().

Отсюда логически вытекает следующее соглашение: *название функции обычно начинается с глагола*: get*, set*, create*, prepare*, make*, remove* и т.д.

Из этого, в свою очередь, неизбежно следует требование, что *одна функция выполняет только одно действие*. Все инструкции, составляющие тело функции, должны служить лишь одной задаче, отраженной в названии функции.


### Список параметров, принимаемых функцией

Мы можем передать внутрь функции любую информацию, используя *параметры функции*:

```javascript
/**
 * Находим большее из двух чисел
 * @param {number} value1 Первое число
 * @param {number} value2 Второе число
 * @return {number} Найденный максимум
 */
function getMax(value1, value2) {
    return value1 > value2 ? value1 : value2;
}

alert(getMax(10, 11));  // 11
```

Если параметр описан при создании функции, но не указан при ее вызове, то его значением становится undefined.
Существует возможность задать *параметры по умолчанию (default parameters)*. 
В этом случае, если параметр не передан, он получит некое заранее предопределенное значение:

```javascript
/**
 * Выводим приветствие пользователю
 * @param {string} Имя пользователя
 */
function sayHello(name = 'Гость') {
    alert(`Приветствую, ${name}!`);
}

sayHello('Виталий');    // Приветствую, Виталий!
sayHello();             // Приветствую, Гость!
```

Независимо от того, сколько параметров указано при объявлении функции, при вызове функции можно передавать в нее *любое* количество аргументов. Если передано меньше аргументов, чем указано параметров при объявлении функции, недостающие параметры, как было описано выше, получат значение undefined. Если же передано больше аргументов, чем указано при объявлении функции, это не вызовет ошибку, а доступ к ним можно получить при помощи массива *arguments*.

```javascript
/**
 * Находим большее из любого количества чисел
 * @return {number} Найденный максимум
 */
function getMax() {
    let max = 0;
    // Получаем доступ к переданным аргументам через предопределенный массив arguments
    for (let i = 0; i < arguments.length; i++) {
        if (max < arguments[i]) max = arguments[i];
    }
    return max;
}

getMax(10, 20, 15);             // 20
getMax(1, 2, 15, 55, 0, -1);    // 55
```

### Возврат значения

Функция может вернуть результат, который будет передан в вызвавший её код. 
Директива *return*, которая передает "наружу" результат работы функции, может находиться в любом месте тела функции. 
Как только выполнение доходит до этого места, функция останавливается и значение возвращается в вызвавший её код.
Вызовов return может быть несколько, например, в разных ветях *if-else* или *switch-case*.
Если же в теле функции нет оператора return или используется пустой return, то результат функции будет всегда undefined.


## Замыкания и лексическое окружение

Разговор о функциях в JavaScript невозможен без понимания концепций **замыкания** и **лексического окружения**.

Понятие **лексическое окружение** в JavaScript относится к возможности доступа к переменным, функциям и объектам на основе их расположения в исходном коде. Все переменные внутри функции – это свойства специального внутреннего объекта *лексического окружения*, который создаётся при её запуске. При запуске функция создаёт объект лексического окружения, записывает туда аргументы, функции и переменные. В конце выполнения функции объект лексического окружения обычно выбрасывается и память очищается. 

Что же касается **замыкания**, то замыкание — это функция, у которой есть доступ к лексическому окружению (т.е., проще говоря, области видимости), сформированному внешней по отношению к ней функции даже после того, как эта внешняя функция завершила работу. Это значит, что в замыкании могут храниться переменные, объявленные во внешней функции и переданные ей аргументы. 
Другими словами, замыкание даёт нам доступ к лексическому окружению внешней функции из внутренней функции, даже если внешняя функция уже была завершена. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

Рассмотрим работу замыканий на примере:

```javascript
function getCounter() {
    let counter = 0;
    return function() {
        return counter++;
    }
}

let count = getCounter();
console.log(count());   // 0
console.log(count());   // 1
console.log(count());   // 2
```

Функция *getCounter()* возвращает в качестве результата своей работы новую функцию. Далее мы несколько раз вызываем эту функцию. И несмотря на то, что первоначальная функция *getCounter()* уже отработала, наша функция *count()* по-прежнему имеет доступ к переменной *counter*, объявленной в родительской функции. Так как функция *count()* представляет собой замыкание, лексическое окружение функции-родителя сохраняется до тех пор, пока это необходимо.


## Функциональные выражения

Другой способ объявить функцию - использовать *функциональное выражение*.
В этом случае функция объявляется при инициализации переменной:

```javascript
const name = function [some_name]([parameters]) {
    // Тело функции
    return result;  // Необязательный возврат результата
};
```

Эта запись вполне валидна благодаря тому, что в JavaScript функция является *типом данных*. А значит, функции можно присваивать и переприсваивать переменным, передавать в качестве аргумента другой функции, возвращать как результат ее работы. 
Необязательное *some_name* может быть использовано для упрощения отладки кода или для рекурсивного обращения функции к себе самой. 
При этом функцию, объявленную как функциональное выражение, нельзя вызвать в коде до ее объявления.

Функциональные выражения особенно удобны, когда функция передаётся аргументом другой функции, например:

```javascript
function getData(id, callback, errback) {
    let result = getFromDB(id);
    return result ? callback(result) : errback();
}

getData(
    5,
    function(res) { setToElement(res); },
    function() { alert('Ошибка получения данных'); }
);
```

В этом примере в функцию getData() передается не только идентификатор данных, которые требуется получить, но и функции, которые сразу будут выполнены в зависимости от полученного результата. Например, функция errback() может вывести сообщение об ошибке, а функция callback() как-то дополнительно подготовить данные и т.д.


## Ключевое слово this

В JavaScript **this** — это текущий контекст исполнения функции. Поскольку функцию можно вызвать многими способами, то разные способы вызова могут определять разный контекст.

Рассмотрим случай, когда функция вызывается как метод объекта.
Как правило, методу объекта необходим доступ к информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия.

В этом случае *this* будет указывать на сам этот объект, и его можно будет использовать доступа к свойствам объекта из функции внутри него самого:

```javascript
let user = {
    name: 'Виталий',
    age: 32,

    sayHello() {
        // this - это "текущий объект"
        alert(this.name);
    }
};

user.sayHello(); // Виталий
```

В простейшем же случае, когда функция вызывается самым "стандартным" способом, *this* будет ссылаться на глобальный объект. Для кода, который выполняется на странице браузера, это будет объект *window*:

```javascript
function someFunction() {
    console.log(this);
}

someFunction();   // Window { ... }
```

## Переопределение this: методы call, apply и bind

Существуют методы, позволяющие задать значение *this* внутри функции явным образом: call, apply, или bind.

Методы *.call()* и *.apply()* используются для вызова функции с заданным контекстом:

Метод *f.call(someObject[, arg1[, arg2[, ...]]])* принимает в качестве первого аргумента someObject контекст вызова, а список аргументов arg1, arg2, ... передаётся вызываемой функции *f*.

Метод *f.apply(someObject, [args])* принимает в качестве первого аргумента someObject контекст вызова, а array-like объект [args] передаётся вызываемой функции *f* в качестве аргумента.

```javascript
function helloWorld(name) {
    console.log(this.message + name);
}

helloWorld.call({ message: 'Привет, ' }, 'Виталий');        // Привет, Виталий
helloWorld.apply({ message: 'Добрый вечер, ' }, ['Анна']);  // Добрый вечер, Анна
```

Вызов метода *f.bind(someObject)* создаёт новую функцию с тем же телом и областью действия, что и *f*, но там, где в исходной функции используется *this*, в новой функции оно постоянно будет связано с первым аргументом *bind*, независимо от того, как функция используется.

```javascript
function someFunction() {
    console.log(this);
}

const helloWorld = someFunction.bind({ message: 'Привет, мир' });
helloWorld();   // { message: 'Привет, мир' }
```

### Частичное применение

Мы можем привязать не только *this*, но и аргументы.
В этом случае также можно использовать метод *bind()*, в том числе для реализации, например, такого приема программирования, как  *частичное применение*.

Частичное применение - это процесс предачи части аргументов функции, который возвращает другую функцию, принимающую оставшиеся аргументы.

Полный синтаксис *f.bind(someObject, [arg1], [arg2], ...)*, как мы видим, предусматривает возможность передачи аргументов. Используя эту возможность, мы можем создавать новые функции, переопределив часть передаваемых аргументов:

```javascript
function sayHello(message, user) {
    alert(message + user.name);
}

let sayHelloEn = sayHello.bind(null, "Hello ");
let sayHelloRu = sayHello.bind(null, "Привет, ");

sayHelloEn({ name: "Alex" });     // Hello Alex
sayHelloRu({ name: "Виталий" });  // Привет, Виталий
```

В этом примере вызов *sayHello.bind(null, "Hello ")* создаёт новую функцию sayHelloEn, которая передаёт вызов sayHello, фиксируя null как контекст, и "Hello " – как первый аргумент. Остальные аргументы передаются как есть. Это и называется частичное применение – мы создаём новую функцию, фиксируя некоторые из существующих параметров.

В данном случае мы не используем *this*, но поскольку для *bind()* это обязательный параметр, необходимо передать туда что-нибудь. Например, null.

В ряде случаев использование подобных приемов позволяет сделать код более наглядным и красивым.


## Стрелочные функции

Стрелочные функции - еще одна альтернативная нотация, рекомендованная в новой спецификации.
Все нижеприведенные способы объявления являются вариантами стрелочной функции:

```javascript
let имя = (параметры) => выражение;
    
let имя = параметр => выражение;
    
let имя = () => выражение;
   
let имя = (параметры) => {
    // тело функции
    return результат;
};
```

Как видим, этот способ отличается от предыдущего варианта краткостью кода, но не только.
Например, стрелочная нотация лексически связывает значение *this*. Другими словами, внутри стрелочной функции не создается собственный *this*, а используется тот, который актуален в контексте ее вызова.

Кроме того, стрелочные функции всегда анонимны и у них нет встроенного псевдомассива *arguments*.
Поэтому, если нам все же нужно по какой-то причине иметь доступ к переданным аргументами, сколько бы их ни было передано, мы можем в этих целях использовать spread:

```javascript
let function1 = (param1, param2, ...rest) => {
    // Все параметры, кроме param1 и param2, содержатся в массиве rest
};
```

Также поддерживаются параметры со значениями по умолчанию:

```javascript
let function2 = (param1 = defaultValue1, param2, …, paramN = defaultValueN) => {
    // Код функции
}
```

При этом важно иметь в виду, что методы call, apply и bind не применимы по отношению к стрелочным функциям:

```javascript
let helloWorld = () => {
    console.log(this);
}
helloWorld.call({ customThis: true });  // Window { ... }
```


## Немедленно вызываемая функция (IIFE)

Немедленно вызываемая функция (Immediately Invoked Function Expression — IIFE) в JavaScript — это конструкция, позволяющая вызывать функцию непосредственно после ее определения. В ряде случаев такая конструкция может использоваться для изоляции данных.
В примере ниже все переменные, использованные внутри IIFE-функции, будут полностью изолированы и не видны нигде "снаружи". 
Аналогично, если "снаружи" есть некие переменные, совпадающие с переменными, используемыми внутри такой функции, наличие таких переменных никак не повлияет на работу IIFE-функции.

Чтобы превратить обычную функцию в IIFE-функцию, достаточно обернуть ее круглыми скобками и приписать вызов функции через "()".

```javascript
    (function(id) {
        // тело функции
    })();
```

Такими функциями вполне могут быть и стрелочные функции:

```javascript
    (() => alert('Привет, мир!'))();
```


## Анонимные функции

Во многих случаях функции могут объявляться без имени - например, объявляться сразу как аргумент другой функции или как результат работы функции.
Пример такого создания анонимной функции мы уже видели в примере выше:

```javascript
    getData(
        5,
        function(res) { setToElement(res); },       // Это анонимная функция
        function() { alert('Ошибка получения!'); }  // И это тоже анонимная функция
    );
```

### Статьи по теме

[Руководство JavaScript. Функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)
[Основы JavaScript. Функции](https://learn.javascript.ru/function-basics)
[Функции в JavaScript: секреты, о которых вы не слышали](https://habr.com/ru/company/otus/blog/530214/)
[Стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
[JavaScript. Замыкания](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)
