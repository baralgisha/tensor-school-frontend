# Работа с массивами

Как мы говорили в предыдущих разделах, в процессе работы программа может хранить данные в именованных хранилищах данных, называемых переменными. Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й, 3-й элементы и т.д. Например, она может понадобиться нам для хранения какого-либо списка: клиентов, товаров, элементов HTML и т.д.

Для хранения таких упорядоченных коллекций в JavaScript существует особая структура данных, которая называется *массив*.


## Создание массива

Есть два способа создать массив:

```javascript
// Простейший способ
let arr = [];

// Чуть более сложный способ
let arr = new Array();

```

Практически всегда используется простой вариант синтаксиса.

При создании массива в скобках мы можем указать начальные значения элементов:

```javascript
// Простейший способ
let clients1 = ['Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.'];

// Чуть более сложный способ
let clients2 = new Array('Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.');

```

При инициализации массивов через **new Array(...)** важно помнить важную особенность синтаксиса.
Если мы укажем в качестве параметра число, то это будет интерпретировано как размерность создаваемого массива.
Если же мы укажем в качестве параметра строку, или если количество передаваемых параметров будет больше одного, эти параметры будут интерпретированы как значения для инициализации массива.

Например:

```javascript
let arr1 = new Array(2);    // Содержимое массива - [undefined, undefined]
let arr2 = new Array(2, 3); // Содержимое массива - [2, 3]
let arr3 = new Array('2');  // Содержимое массива - ['3']

```

Подобная неоднозначность при инициализации массивов методом **new Array()** является потенциальным источником ошибок и одной из причин, почему этот метод используется намного реже, чем более простой способ (с использованием квадратных скобок).

Но это далеко не единственные способы создания массивов.
Для примера можно привести еще несколько вариантов:

```javascript
// Можно создать и инициализировать массив вот так
let arr1 = Array.of(5, 15, 25); // Содержимое массива arr1 - [5, 15, 25]

// Или даже вот так
let arr2 = Array.from('Hello');  // Содержимое массива arr2 - ['H', 'e', 'l', 'l', 'o']

```

В последнем примере нужно пояснить, что функция **Array.from()** позволяет создать массив из любого итерируемого или массивоподобного объекта. Помимо строки, это может быть, например, Set, Map, arguments, HTMLCollection и многое другое (см. напр. [здесь](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from)).

## Доступ к элементам массива

Элементы массива, каким бы методом мы его ни создали, всегда нумеруются начиная с нуля.

Мы можем получить элемент массива, указав его номер в квадратных скобках:

```javascript
let clients = ['Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.'];
alert( clients[0] );        // 'Иванов А.А.'

```

Элемент легко может быть перезаписан по его номеру:

```javascript
let clients = ['Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.'];
clients[1] = clients[0];    // ['Петров А.Б.', 'Петров А.Б.', 'Смирнов Р.А.'];
clients[2] = '';            // ['Петров А.Б.', 'Петров А.Б.', ''];

```

Добавить новый элемент можно просто записав значение по новому (пока еще не существующему) индексу.
При этом, если инициализировать элементы массива не по порядку, интерпретатор создаст недостающие элементы со значением undefined.

```javascript
let clients = ['Иванов А.А.', 'Петров А.Б.'];
clients[2] = 'Смирнов Р.А.';    // ['Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.'];
clients[4] = 'Чижиков Н.Н.';    // ['Петров А.Б.', 'Петров А.Б.', 'Смирнов Р.А.', undefined, 'Чижиков Н.Н.'];

```

Общее число элементов массива содержится в его свойстве **length**:

```javascript
let clients1 = ['Иванов А.А.', 'Петров А.Б.'];
alert( clients1.length );    // 2

let clients2 = new Array(20);
alert( clients2.length );    // 20

let clients3 = new Array('20');
alert( clients3.length );    // 1

```

При этом длина массива является изменяемым свойством.
При изменении длины массива в сторону увеличения новые элементы получают значение undefined, а при уменьшении лишние элементы отбрасываются:

```javascript
let arr = [1, 2];
arr.length = 5;     // [1, 2, undefined, undefined, undefined]
arr.length = 1;     // [1]

let clients2 = new Array(20);
alert( clients2.length );    // 20

let clients3 = new Array('20');
alert( clients3.length );    // 1

```

В массиве могут храниться элементы любых типов:

```javascript
let arr = ['Иванов А.А.', { name: 'Джон' }, true, function() { alert('Привет, мир!'); }];
alert(arr[1].name); // Выводится 'Джон'
if (arr[2]) {       // true
    arr[3]();       // Выполнится функция и выведется 'Привет, мир!'
}

```

## Перебор элементов массива

Одной из самых часто встречающихся задач при работе с массивами является последовательный обход массива.
Простейший способ реализовать это в JavaScript - использовать циклы:

```javascript
let clients = ['Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.'];

for (let i = 0; i < clients.length; i++) {
  console.log(clients[i]);
}

```

Также очень популярен вариант цикла **for..of**:

```javascript

let clients = ['Иванов А.А.', 'Петров А.Б.', 'Смирнов Р.А.'];
for (let client of clients) {
  // При каждой итерации переменной client присваивается одно из значений элементов массива
  console.log(client);  
}

```

## Массив как объект

С точки зрения внутренней реализации JavaScript, массив является частным случаем объекта. А значит, мы можем инициализировать любое поле и обращаться к нему, как к полю объекта:

```javascript
let a = [1, 2, 3];
a.x = 'y';
a['foo'] = bar;

```

## Методы работы с массивами

Существует много встроенных методов и функций для работы с массивами. Мы обзорно рассмотрим наиболее часто используемые.
Для получения детальной информации по этим методам рекомендуем обратиться к официальной документации JavaScript.

### Длина массива

О работе со свойством массива **length** мы достаточно говорили в предыдущих подразделах.

### Поиск индекса элемента в массиве

Для нахождения индекса элемента в массиве используется функция **indexOf()**.
Если такой элемент не найден, возвращается значение -1.

```javascript
let arr1 = [100, 200, 300];
alert( arr1.indexOf(300) ); // 2

let arr2 = ['Иванов А.А.', 'Петров А.Б.'];
alert( arr2.indexOf('Кузьмин П.П.')) ); // -1

```

Более сложный, но и более мощный способ поиска элемента - использовать методы **find()** и **findIndex()**.
Они позволяют получить первый элемент или индекс элемента, удовлетворяющий какому-то условию.
Поиск реализуется при помощи специальной функции поиска, которую мы передаем в качестве параметра.

```javascript
let arr = [0, 0, 3, 2, 0, 1, 5, 4, 4];

function checkRate(rate) {
  return rate >= 4;
};

// Получить индекс элемента со значением больше или равно 4
alert( arr.findIndex(checkRate) ); // 6

```

### Работа со стеком и очередью

Следующие методы предназначены для добавления элементов в начало или конец массива и для получения их, т.е. реализуют функционал стека и очереди.

**push()** - добавляет элементы в конец массива и возвращает новую длину массива.
**pop()** - удаляет последний элемент и возвращает его значение.
**shift()** - добавляет элементы в начало массива и возвращает новую длину массива.
**unshift()** - удаляет первый элемент и возвращает его значение.

Пример:

```javascript
let arr = [1, 2, 3, 4];
arr.push(5);        // Массив содержит значения [1, 2, 3, 4, 5]
arr.shift(0);       // Массив содержит значения [0, 1, 2, 3, 4, 5]
alert(arr.pop());   // Выводит 5, массив содержит [0, 1, 2, 3, 4]

```

### Получение "среза" массива и добавление/удаление элементов

**slice()** - возвращает новый массив, содержащий копию части исходного массива.
**splice()** - изменяет содержимое массива, удаляя/добавляя элементы.

Функция slice() принимает либо 1, либо 2 числовых параметра. Если передан один параметр, функция вернет новый массив, начинающийся с того элемента, номер которого был передан в качестве первого параметра. Если передано 2 параметра, то длина нового массива будет ограничена этим вторым числом.

```javascript
  let arr = [10, 20, 30, 40, 50, 60, 70];
  console.log(arr.slice(2));    // 30, 40, 50, 60, 70
  console.log(arr.slice(2, 5));  // 30, 40, 50, 60  

```

Функция **splice()** имеет более сложную логику входящих параметров:
splice(start)
splice(start, deleteCount)
splice(start, deleteCount, item1)
splice(start, deleteCount, item1, item2, itemN)

Она позволяет одновременно и получить некий срез массива, и удалить из него выбранные элементы, и добавить новые элементы вместо удаленных в старом массиве:

```javascript
let arr1 = [10, 20, 30, 40, 50, 60, 70];
let arr2 = arr1.splice(2, 4, 100);  // arr2 содержит [30, 40, 50, 60]
alert(arr1);  // arr1 теперь содержит [10, 20, 100, 70]

```

### Объединение массивов

Функция **concat()** объединяет два массива в один:

```javascript
let arr1 = [1, 2, 3, 4, 5];
let arr2 = [10, 20, 30, 40, 50];
let arr = arr1.concat(arr2);
console.log(arr); // 1, 2, 3, 4, 5, 10, 20, 30, 40, 50

```

### Группа методов последовательного прохождения по массиву

Функция **forEach()** выполняет указанную функцию один раз для каждого элемента в массиве:

```javascript
// Вычислим сумму элементов в массиве
let arr = [10, 20, 30, 40, 50, 60, 70];
let summ = 0;
arr.forEach(function(n) {
  sum += n;
});
console.log(sum); // 280

```

Функция **map()** создает новый массив с результатом вызова указанной функции для каждого элемента массива.

```javascript
// Создадим новый массив, где каждое значение увеличено в 2 раза
let arr = [10, 20, 30, 40, 50];
let newArr = arr.map(function(n) {
  return n*2;
});
console.log(newArr); // 20, 40, 60, 80, 100

```

Функция **reduce()** применяет функцию к каждому элементу массива и возвращает результирующее значение.
Параметры: reduce(callback[, initialValue]).

```javascript
// Еще один способ вычислить сумму элементов в массиве
let arr = [10, 20, 30, 40, 50];
let sum = arr.reduce(function(acc, n) {
  return acc + n;
}, 0);
console.log(sum); // 150

```

Функция **every()** проверяет, удовлетворяют ли все элементы массива заданному условию и возвращает true/false.

```javascript
// Узнаем, все ли элементы в массиве больше 20. 
// Если хотя бы для одного элемента условие не выполняется, функция вернет false.
let arr = [10, 20, 30, 40, 50];
let result = arr.every(function(n) {
  return n > 20;
});
console.log(result); // false

```

### Spread

Существует интересный способ работы с массивами, когда нам нужно "развернуть" массив в виде совокупности его элементов.
Эта "развертка" называется *spread* и выглядит как три точки перед названием массива. Использовать spread массива можно во всех ситуациях, где интерпретатор ожидает наличие *нескольких* переменных и мы хотим в качестве этих переменных передать элементы нашего массива. Например:

```javascript
function func(a1, a2, a3) {
  // Эта функция что-то делает с переданными параметрами
}

let arr = [1, 2, 3];
func(...arr);   // "Разворачиваем" массив с помощью spread и передаем полученные элементы в функцию

// Это эквивалентно варианту:
func(arr[0], arr[1], arr[2]);

```

Спрэд можно использовать при создании и/или конкатенации массивов:

```javascript
let arr1 = [1, 2, 3];
let arr2 = [10, 20, 30];

let arr3 = [...arr1, ...arr2];  // [1, 2, 3, 10, 20, 30]

```


### Статьи по теме

[Создание массива и объект Array](https://metanit.com/web/javascript/5.3.php)
[Стандартные встроенные объекты. Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)
[Массивы](https://learn.javascript.ru/array)
