# Примитивы

В JavaScript все типы данных можно разделить на две большие группы.
Первая группа — это примитивы, а вторая — объекты (включая функции).
Соответственно, примитивами называются простые типы данных, которые не являются объектами.
Парадокс, однако, в том, что с точки зрения внутренней реализации JavaScript *все* типы данных являются объектами, и примитивы в этом плане не исключение. Так что проще просто перечислить, какие типы данных мы имеем в виду, говоря о примитивах.
- [number](#number),
- [string](#string),
- [boolean](#boolean),
- [null](#null),
- [undefined](#null),
- [symbol](#symbol),
- [bigint](#bigint).

Узнать тип переменной можно с помощью оператора **typeof**, который возвращает строку с названием типа:

```javascript
const flag = true;
const message = 'Привет, мир!';
const count = 0;

console.log(typeof flag);           // boolean
if (typeof flag === 'string') {     // true
    alert(typeof count);            // number
}
```

## <a name="number"></a>Числа (number)

Тип **number** используется для целочисленных и вещественных чисел.
При этом явного деления на целочисленные и вещественные числа в JavaScript нет.

```javascript
const p = 3;        // typeof p === 'number'
const pi = 3.14;    // typeof pi === 'number'
```

Интересной особенностью JavaScript является то, что мы можем делить числа на ноль и это не вызовет ошибки.
Результатом такой операции будет особое значение *Infinity*:

```javascript
const divisionByZero1 = 3 / 0;      // Infinity
const divisionByZero2 = -3 / 0;     // -Infinity
alert(typeof divisionByZero1);      // number
```

При необходимости мы можем получить числовое значение из строки.
В примере ниже символ плюса перед строкой указывает интерпретатору на необходимость привести строку к числу:

```javascript
const text = '305';     // typeof p === 'string'
const value = +text;    // typeof p === 'number'
```

Более явным способом привести строку к целому числу является использование функции **parseInt(string, radix)**. Первым параметром функция принимает строку, которую требуется преобразовать в число, а вторым - основание системы счисления для этой строки. 
Интерпретатор использует для преобразования цифры с начала строки и до первого нецифрового значения, если таковое присутствует в строке. Если же строка сразу начинается с нечислового значения, функция преобразования вернет значение NaN:

```javascript
const value1 = parseInt('10', 10);      // 10
const value2 = parseInt('10', 2);       // 2
const value3 = parseInt('30.51', 10);   // 30
const value4 = parseInt('3.14 - это число пи', 10); // 3
const value5 = parseInt('Число пи: 3.14', 10);      // NaN
```

**NaN (Not-a-Number)** - это специальное значение, которое мы получаем в случае неудачной попытки преобразования нечисловых данных к числу. При этом NaN, формально, тоже является числом. Чтобы проверить, не содержит ли переменная значение NaN, мы можем использовать функцию **isNaN()**:

```javascript
const value = parseInt('Текст', 10);
if (isNaN(value)) {      // true
    console.log(typeof value);  // number
}
```

Здесь важно также отметить, что мы не можем вместо функции isNaN() использовать просто сравнение вида "value == NaN". Дело в том, что NaN является неравным (посредством сравнения через "==" или "===") любому другому значению, включая другое значение NaN. То есть, сравнение вида NaN == NaN всегда будет возвращать false. Именно поэтому проверка значения на NaN реализуется всегда с помощью функции isNaN().

Возвращаясь к приведению численных типов к строке, аналогичным образом, функция **parseFloat(string)** позволяет преобразовывать переданную строку в вещественное значение.

Более сложные математические преобразования (такие, как округление вещественного числа, вычисление модуля, возведение числа в степень, различные тригонометрические функции и пр.) реализуются при помощи встроенной библиотеки **Math**:

```javascript
const pi = Math.PI;             // 3.141592653589793
console.log(Math.round(pi));    // Округление до 3
console.log(Math.random());     // Случайное число от 0 до 1, например 0.7364754560947793
```


## <a name="string"></a>Строки (string)

Для работы со строковыми значениями используется тип string.

Строки могут заключаться в одинарные или двойные кавычки, а также в апострофы. 
При этом апострофы используются для создания т.наз. шаблонных строк - то есть таких, в которых можно делать автоподстановку других переменных. Область для подстановки выделяется знаком доллара и фигурными скобками:

```javascript
const message1 = "Привет";  // Можно двойные кавычки
const message2 = 'мир';     // Можно одинарные (рекомендуется)
const message3 = `${message1}, ${message2}!`;   // Привет, мир!
```

Шаблонные строки делают также автоматическое приведение типов к строке и даже позволяют выполнять вычисления:

```javascript
const pi = 3.14;    // number
const count = 1;    // number
const message1 = `Число пи: ${pi}`;
const message2 = `Увеличиваем счетчик: ${count + 1}`;
```

Существует множество способов приведения числа к строке. 
Одним из самых простых и часто используемых методов является функция toString().
В качестве необязательного параметра может передаваться основание системы счисления для итогового отображения строки. По умолчанию число будет иметь основание 10:

```javascript
const count = 10;    // number
const message = count.toString() + ' ' + count.toString(2); // '10 2'
```

Из примера выше также видно, что строки можно конкатенировать при помощи операции сложения.

Неявное преобразование числа к строке произойдет при сложении числа и строки:

```javascript
const count = 1;
console.log(1 + '0');   // '10'
```

Чуть более сложные, но более мощные способы приведения числа к строке позволяют также выполнять округление с заданной точностью и форматирование итоговой строки, предопределяя либо общее число символов в результирующей строке (функция **toPrecision ([precision])**), либо количество знаков после запятой (функция **toFixed([precision])**).

```javascript
console.log((60).toPrecision(3));       // '60.0'
console.log(60.1234.toPrecision(3));    // '60.1'

console.log((60).toFixed(3));           // '60.000'
console.log(60.1234.toFixed(3));        // '60.123'
```

Для получения длины строки используется свойство length.
Можно обращаться к символам строки по их индексу, используя для этого квадратные скобки [], либо использовать функцию **charAt()**:

```javascript
const message = 'Hello world!';
console.log(message[0]);        // 'H'
console.log(message.charAt(1)); // 'e'
```

Заменить отдельный символ таким образом не получится, т.к. строки в JavaScript являются немутабельными:

```javascript
const message = 'Hello world!';
message[0] = '*';
console.log(message); // 'Hello world!';
```

Тем не менее, мы можем эффективно работать со строками, используя для этого множество специализированных строковых функций:
- **toLowerCase(string)** – преобразует все символы в строке к строчным символам,
- **toUpperCase(string)** – преобразует все символы в строке к заглавным символам,
- **replace(regexp|substr, newSubStr|function[, flags])** – заменяет фрагмент строки (можно использовать регулярные выражения),
- **substring(indexA[, indexB])** – возвращает подстроку в строке,
- **search(substring)** – находит индекс начала искомой подстроки,
- **trim(string)** – очищает начало и конец строки от пробелов,
и т.д.


## <a name="boolean"></a>Логический тип (boolean)

Для работы с логическими значениями используется тип boolean.
Такая переменная принимает значения true или false.
В случае приведения логического типа к числу, true становится единицей, а false нулем.

Значение любого другого типа может быть приведено к логическому типу. 
Можно (хоть и не рекомендуется) сделать это явным образом, используя функцию Boolean(), либо (как обычно и делают разработчики) - с помощью "!!".
В общем случае, любое непустое значение будет приведено к true, а любое пустое (включая значения null и undefined) - к false:

```javascript
const message = 'Hello world!';
const count1 = 100;
const count2 = 0;

console.log(!!message);         // true
console.log(!!count1);          // true
console.log(Boolean(count2));   // false
```


## <a name="null"></a>Типы null и undefined

Типы null и undefined в каком-то смысле похожи, потому что по сути оба означают отсутствие значения.
Общепринятым соглашением является практика, что если переменная объявлена, но не инициализирована – ее значение undefined.
Если значение у переменной присвоено, но "отсутствует" – это null.

```javascript
let value;      // undefined
value = null;   // null
```

Тем менее, нет никаких ограничений самого JavaScript на то, чтобы переменной явно присвоить значение undefined:

```javascript
let value = true;
value = undefined;
```


## <a name="symbol"></a>Тип symbol

Символ (symbol) — это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов. 
В реальной разработке он используется редко, поэтому мы практически не будем на нем останавливаться.

По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. 
Задавая ключ посредством типа symbol, мы можем быть совершенно уверены в уникальности наших ключей.
В силу этой гарантированной уникальности, две переменных типа symbol, имеющих одинаковое значение, не будут равны друг другу:

```javascript
let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2);  // false
```

## <a name="bigint"></a>Тип BigInt

Тип BigInt используется для работы с очень большими числами, когда не хватает возможностей примитива Number.
Чтобы дать понять интерпретатору, что мы хотим использовать BigInt, достаточно использовать символ «n» в конце числа:

```javascript
const bigInt = 1234567890123456789012345678901234567890n;
```

Чтобы создать значение типа BigInt, можно также вызвать функцию BigInt, которая создаст число типа BigInt из переданного аргумента. Аргументом может быть число, строка и др.:

```javascript
const bigintFromString = BigInt('1234567890123456789012345678901234567890');
console.log(bigintFromString);  // 1234567890123456789012345678901234567890n

const bigintFromNumber = BigInt(10); 
console.log(bigintFromNumber); // 10n
```

Современные версии JavaScript позволяют при записи чисел использовать разделители разрядов в виде символа подчеркивания "_". Это добавляет наглядности и делает число более читабельным. Поскольку очень большие числа BigInt обычно не слишком наглядны, использование разделителей может упростить восприятие кода:

```javascript
const large = 9_007_199_254_741_001n;
console.log(large); // 9007199254741001n
```

BigInt можно использовать как обычные числа:

```javascript
const large = 9_007_199_254_741_001n + 1n;
console.log(large);   // 9007199254741002n
```

Как видим, BigInt во многом похож на Number, но следует помнить, что:
- его нельзя использовать с методами во встроенном объекте Math,
- BigInt нельзя смешивать в операциях с любыми экземплярами Number,
- к числам BigInt нельзя применить унарный оператор "+".

Все операции с числами типа BigInt возвращают BigInt.
Поэтому операция деления возвращает округлённый результат, без дробной части:

```javascript
const large = 9n / 2n;
console.log(large);   // 4n
```

Поскольку в вычислениях мы не можем смешивать BigInt и обычные числа, следует явно их конвертировать, используя либо приведение BigInt(), либо Number():

```javascript
let bigint = 9n;
let number = 5;

// конвертируем number в bigint
alert(bigint + BigInt(number)); // 14n

// конвертируем bigint в number
alert(Number(bigint) + number); // 14
```

### Статьи по теме

[Примитив](https://developer.mozilla.org/ru/docs/Glossary/Primitive)
[Методы у примитивов](https://learn.javascript.ru/primitives-methods)
