# Рекурсия

## Что такое рекурсия

В процессе работы программы в теле функции для выполнения подзадач могут быть вызваны какие-то другие функции.
Частный случай такой ситуации – когда функция вызывает сама себя. Подобный вызов называется рекурсией.
То есть, проще говоря, рекурсия – это функция, которая сама вызывает себя.


## Когда уместно использовать рекурсию

Этот приём программирования бывает очень полезным для определенного класса задач. А именно, использование рекурсии целесообразно в ситуациях, когда задача может быть естественно разделена на несколько аналогичных, но более простых задач, или же в случаях, когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи.

Конечно, любая задача, которую можно решить с использованием рекурсии, может быть решена и без ее использования. Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее в плане быстродействия и экономии ресурсов. Но решение подобной задачи при помощи циклов может быть нетривиальным и некрасивым, особенно когда в функции в зависимости от условий используются различные подвызовы или когда ветвление более сложное. В этом случае подобная оптимизация может не иметь смысла.

Очень часто код с использованием рекурсии намного более компактный, лёгкий для понимания и поддержки.


## Пример рекурсивной программы

В большинстве учебников используется применение рекурсии для вычисления факториала числа или возведения числа в степень. Давайте отойдем от этой традиции и возьмем, например, задачу вычисления чисел Фибоначчи.

Как мы помним, ряд чисел Фибоначчи задается при помощи формулы F(n) = F(n-1) + F(n-2).

С использованием рекурсии задача может быть решена, например, следующим образом:

```javascript
/**
 * Вычисление n-го члена ряда Фибоначчи
 * @param n {number} Номер числа в ряду Фибоначчи
 * @return {number} Вычисленное число Фибоначчи
 */
function Fibonacci(n){
    if (n < 3) {
        return 1;
    } else {
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
```

В теле функции Fibonacci (а на самом деле, в *любой* рекурсивной функции) в определенный момент исполнение делится на две ветви. В нашем случае это разделение реализовано в условии *if (n < 3)*.

Если это условие выполняется, то это сразу же приводит к очевидному результату: функция возвращает единицу, потому что первые два числа в ряду Фибоначчи равны единице и не требуют никаких дополнительных вычислений. 
Данная ветка в рекурсивной функции называется *базой рекурсии*.

Если же условие не выполняется, исполнение переходит на вторую ветку. Она называется *шаг рекурсии*. 
В ней мы сводим задачу к более простому действию (сложению) и более простой аналогичной задаче (Fibonacci с меньшим n). Последующие шаги упрощают задачу всё больше и больше, пока n не достигает минимальных значений.
В нашем примере функция Fibonacci рекурсивно вызывает саму себя до n <= 2.


## Глубина рекурсии

Общее количество вложенных вызовов (включая первый) называют *глубиной рекурсии*.
При этом максимальная глубина рекурсии ограничена движком JavaScript. В ряде движков существуют автоматические оптимизации, но в целом глубина рекурсии всегда конечна. Это ограничивает применение рекурсии, но она всё равно широко распространена: для решения большого числа задач рекурсивный способ решения даёт более простой код, который легче поддерживать, а особая глубина рекурсии часто не требуется.

Если ваш код не совсем тривиален и включает в себя достаточно сложную логику, в ряде случаев может быть целесообразно вести собственный подсчет числа итераций, а также предусмотреть принудительное прекращение рекурсивного вызова функций, если количество итераций превысило какое-то пороговое значение, не дожидаясь, пока выполнение программы будет прервано из-за ошибки переполнения стека. Впрочем, возможно, это как раз тот случай, когда задачу лучше решить без использования рекурсии.


### Статьи по теме

[Рекурсия](https://ru.hexlet.io/courses/introduction_to_programming/lessons/recursion/theory_unit)
[Как работает рекурсия – объяснение в блок-схемах и видео](https://habr.com/ru/post/337030/)
[Рекурсия и стек](https://learn.javascript.ru/recursion)
