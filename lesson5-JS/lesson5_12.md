# Работа с объектами

**Объект** — это тип данных, представляющих собой некий набор свойств и методов работы с ними.
Каждое свойство состоит из имени и значения, ассоциированного с этим именем.

**Метод** — это свойство объекта, являющееся функцией.

Например, если мы хотим создать сущность для описания кадровых данных о сотруднике, нам понадобится его ФИО, год рождения, пол, информация о квалификации, образовании и т.д. Все эти данные о сотруднике удобно свести в общую сущность, а также реализовать методы для работы с этими данными.

## Создание объекта

Создать объект предельно просто, причем JavaScript предлагает сразу несколько вариантов, как это можно сделать. Для большинства ситуаций подходит простейший способ, но в ряде случаев его оказывается недостаточно и тогда можно использовать другие варианты.

Простейший способ создать объект в JavaScript выглядит следующим образом:

```javascript
let obj = {};   // Создан объект obj
```

Чуть более длинный (и менее популярный) вариант выглядит так:

```javascript
let obj = new Object(); // Создан объект obj
```

Для создания объекта можно использовать функциональный стиль, когда мы создаем некую функцию, которая в дальнейшем выступает как конструктор для объекта. При создании экземпляра такого объекта необходимо перед именем функции использовать ключевое слово **new**:

```javascript
function Foo() {
    // Тело функции
}

let obj = new Foo();    // Создан объект obj
```

Наконец, последний способ создания объектов, который мы рассмотрим - это *использование классов*.
Классы в JavaScript были введены в ECMAScript 2015 и представляют собой синтаксический сахар над существующим в JavaScript механизмом прототипного наследования. Создать класс в JavaScript можно следующим образом:

```javascript
class Foo() {
    ...
}

let obj = new Foo();    // Создан объект obj
```

## Работа с объектами

Инициализация объекта и его изменение возможно в любой момент:

```javascript
    let obj = {};               // Создан новый объект
    obj.key = 10;               // Добавлено числовое свойство с ключом "key" и ему присвоено значение 10
    obj.another = 'string';     // Добавлено строковое свойство с ключом "another" и ему присвоено значение 'string'
    obj.more = {};              // Добавлено объектное свойство с ключом "more" и ему присвоено значение 'пустой объект'
```

Ключом для создаваемого свойства объекта может быть любая строка, допускается использование подчеркиваний. 
В названии свойства можно использовать кириллицу и даже пробелы, но в этом случае к свойству придется обращаться через квадратные скобки:

```javascript
    let obj = {};
    obj.another_key = false;
    obj['ключ с пробелом'] = 10;    // Это валидный ключ, если к нему обращаться через []

    alert(obj['ключ с пробелом']);  // 10
```

В качестве ключа может быть использовано число, но в этом случае необходимо помнить, что числовые индексы приводятся к строкам:

```javascript
    let a = {};
    a[1] = 'Привет, мир!'

    alert(a['1']);  // Привет, мир!
```

Ключи в объекте негистронезависимы:

```javascript
    let obj = {};
    obj.key = false;    // Это три
    obj.Key = true;     // совершенно разных
    obj.KEY = null;     // ключа
```

Объект может быть инициализирован сразу в момент создания:

```javascript
    let obj = {
        key: 'value',
        another: 123,
        child: {
            x: 10
        },
        sayHello: function() {
            alert('Hello!');
        }
    };

    obj.another = null;
    obj.sayHello();
```

Свойство объекта при необходимости легко можно удалить при помощи оператора *delete*:

```javascript
    let obj = {
        key: 1
    };
    
    console.log(obj.key);   // 1
    delete obj.key;         // удаление свойства
    console.log(obj.key);   // undefined
```

## Прототип объекта
Каждый объект имеет "прототип" - специальное свойство, в котором находится либо null, либо ссылка на другой объект. При обращении к свойству объекта, интерпретатор сначала пытается найти его на самом объекте, и если оно отстутствует, то он автоматически начнёт подниматься по цепочке прототипов. Через прототипы в JavaScript реализуется наследование.

Разберём как это работает:

![Prototype](Prototype.png)

Допустим, у нас есть объект person, который описывает человека и объект teacher, который описывает учителя. В прототипе teacher находится ссылка на person.

При обращении к свойству subject, значение свойства будет найдено в самом объекте teacher. При обращении к свойству name интерпретатор не найдёт его в объекте teacher и автоматически его из объекта person.

Современным способом указания прототипа является наследование класса через слова extends. Подробнее это будет разобрано в следующих главах.

## "Обход" объекта

Часто бывает необходимо последовательно пройтись по всем свойствам объекта - например, для отображения этих свойств на экране.
Простой и удобный способ сделать это - использовать конструкцию **for-in**:

```javascript
    let obj  = { ... };
    for (let key in obj) {
        // Сейчас название свойства содержится в переменной key,
        // а получить доступ к значению этого свойства можно через obj[key]
        console.log(`${key}: ${obj[key]}`);
    };
```

В этом коде есть подводный камень: *for-in* обойдёт все перечисляемые свойства объекта, включая унаследованные от объекта-прототипа. Если мы хотим пройтись только по "собственным" полям объекта, нам нужно добавить проверку *hasOwnProperty()*:

```javascript
    ...
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            console.log(`${key}: ${obj[key]}`);
        }
    };
```

В большинстве современных браузеров есть возможность получить список всех названий свойств объекта в виде массива при помощи функции Object.keys(), и этот способ также можно использовать для обхода объекта:

```javascript
    let obj  = { ... };
    let keys = Object.keys(obj);     // массив строк-ключей
    for (let i = 0; i < keys.length; i++) {
        console.log(`${keys[i]}: ${obj[keys[i]]}`);
    }
```

Также существуют удобные функции Object.values() и Object.entries(). 
Метод  Object.values() возвращает массив значений перечисляемых свойств объекта, а метод Object.entries() возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value]. Помимо классического цикла *for*, для данной задачи часто используют функциональные циклы, такие, как *forEach()*, *map()* и т.д.:

```javascript
    let obj  = { ... };
    let entries = Object.entries(obj);  // массив пар [key, value]
    entries.forEach((data) => {
        console.log(`${data[0]}: ${data[1]}`);
    });
```


## Деструктуризация объектов

**Деструктуризация** (или **деструктурирующее присваивание**) – это специальный синтаксис, который позволяет нам «распаковать» объекты в набор переменных, так как иногда они более удобны.

Например:

```javascript
    let obj  = {
        width: '100px',
        height: '100px',
        color: '#fefefe'
    };
    let { width, height, color } = obj;     // width == '100px', height == '100px', color == '#fefefe'
```

В примере выше в результате использования деструктуризации значения свойств полей были разнесены по соответствующим переменным. При этом, если поля с таким названием в объекте не окажется или оно не будет определено, то существует возможность задать переменной значение по умолчанию:

```javascript
    let obj  = {
        width: '100px',
        height: '100px',
        color: '#fefefe'
    };
    let { width, height, color, title = 'Name'} = obj;
```

Если же мы хотим, чтобы в процессе деструктуризации объекта соответствие имен полей и переменных было произвольным, мы можем явно указать, из какого свойства нам нужно получить значение:

```javascript
    let obj  = {
        w: '100px',
        h: '100px',
        c: '#fefefe'
    };
    let { width: w, height: h, color: c} = obj;
```


## Spread

В [предыдущем разделе](https://pro-edu.tensor.ru/tensor/lesson/page.php?id=3166&sectionid=4&pageid=11)), мы уже говорили про то, как использовать **spread** для массивов. **Spread** для объектов также существует и может быть использован, например, для интеграции полей одного объекта в другой объект:

```javascript
let data = { height: 30, color: '#fefefe', title: 'Name' };
let obj = { width: 100, ...data};
console.log(obj);   // { width: 100, height: 30, color: '#fefefe', title: 'Name' }
```

Также мы можем использовать spread для объединения двух объектов в третий:

```javascript
let obj1 = { width: 100, height: 30 };
let obj2 = { color: '#fefefe', title: 'Name' };
let obj = { ...obj1, ...obj2 };

console.log(obj);   // { width: 100, height: 30, color: '#fefefe', title: 'Name' }
```

Совместное использование деструктуризации и spread позволяет красиво и лаконично решать различные задачи, возникающие при работе с объектами.
В этом случае мы можем "развернуть" часть полей из объекта, а оставшиеся свойства переупаковать в новый объект:

```javascript
let { width, ...other} = { width: 100, height: 30, color: '#fefefe', title: 'Name' };
console.log(width);   // 100
console.log(other);   // { height: 30, color: '#fefefe', title: 'Name' }
```

Удобно использовать подобный функционал, оформляя его в виде [стрелочных функций](https://pro-edu.tensor.ru/tensor/lesson/page.php?id=3166&sectionid=4&pageid=13).

Например, мы можем сделать стрелочную функцию, с помощью которой переименуем свойство объекта title:

```javascript
const rename = ({ title, ...object }) => ({ TITLE: title, ...object });
const obj = { width: 100, height: 30, color: '#fefefe', title: 'Name' };
rename(obj);
console.log(obj);   // { TITLE: 'Name', width: 100, height: 30, color: '#fefefe' };
```

### Статьи по теме

[Объекты: основы](https://learn.javascript.ru/object)
[Работа с объектами](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Working_with_Objects)
