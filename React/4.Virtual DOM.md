# Virtual DOM
> Виртуальный DOM (VDOM) — это концепция программирования, в которой идеальное
> или «виртуальное» представление пользовательского интерфейса хранится в памяти
> и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM.
## Как в целом работает
Для показа HTML-элементов на странице браузер использует DOM-дерево.
DOM-дерево придумывали для отображения статичных интерфейсов, а не для динамичных
приложений.
Манипуляции с DOM-деревом очень дороги и сильно влияют на производительность
приложения, пользователям становится неприятно работать и они уходят.

Virtual DOM &ndash; это легковесная копия DOM-дерева с необходимыми параметрами
отображения DOM-элементов.

Когда мы хотим изменить DOM-дерево, мы изменяем состояние или проп компонента,
вызывается метод `render()` и происходит обновление следующим образом:
  1. Создается новое VDOM-дерево, состоящее из набора вложенных функций
`jsx('element', {...props})`, которые являются вершинами этого дерева.
  2. Новое дерево сравнивается с текущим.
  3. Изменения полученные при сравнении попадают в DOM-дерево.

![alt-Применение изменений через Virtual DOM][tree_diff]

VDOM-дерево по своей сути является набором вложенных вызовов функции
`jsx('div', {className: 'greeting', children: 'Привет, мир!'})`, которые являются
вершинами этого дерева.

### Какие сложности при работе с DOM-деревом
  1. Если DOM-дереву дать сначала один набор элементов, а потом немного измененный, то сначала элементы будут полностью удалены,
а затем добавлены с нуля.
     ```jsx
     <ul>
       <li>первый</li>
       <li>второй</li>
     </ul>
     // верхние элементы удалятся, а нижние будут созданы с нуля
     <ul>
       <li>первый</li>
       <li>второй</li>
       <li>третий</li>
     </ul>
     ```
  2. При замене одного HTML-элемента на другой с новым классом, также происходит
     полная перерисовка, а не смена атрибута.
     ```jsx
     <div className="before" title="stuff" />
     // HTML элемент будет удален и вставлен заново, хотя поменялся только класс
     <div className="after" title="stuff" />
     ```
  3. Добавление подряд нескольких различных элементов довольно дорого.
     ```jsx
     var ul = document.createElement('ul');
     document.body.appendChild(ul); // сначала в документ
     for (...) ul.appendChild(li); // потом узлы
     // Вставка по примеру выше в большинстве браузеров будет дороже
     var ul = document.createElement('ul');
     for(...) ul.appendChild(li);   // сначала вставить узлы
     document.body.appendChild(ul); // затем в документ
     ```

VDOM позволяет решить эти проблемы и минимизировать количество обращений к DOM-дереву,
тем самым увеличивая производительность и отзывчивость приложения.

## Алгоритм сравнения
У VDOM-дерева есть одно "но": при первом отображении интерфейса нам необходимо
построить его с нуля, а используется оно в большей мере для изменения существующего
интерфеса в DOM-дереве.

Сравнение 2 деревьев общим алгоритмом довольно трудоемко O(n^3),
где n — это число элементов в дереве.
Поэтому React накладывает некоторые ограничения на операции сравнения,
что позволяет сравнивать деревья более эффективно O(n).

React руководствуется двумя предположениями при сравнении виртуальных деревьев:
  1. Два элемента с разными типами произведут разные деревья.
  1. Разработчик может указать, какие дочерние элементы могут оставаться стабильными
     между разными рендерами с помощью пропа key.

### Элементы различных типов
Когда React находит различия в корневых элементах, он полностью уничтожает поддерево
и строит новое.
В следующем примере при смене одного корня на другой у компонента внутри будет
потеряно его состояние, поэтому так делать не стоит:
```jsx
<div>
  <Counter />
</div>

<span>
  <Counter />
</span>
```
Если ваши компоненты довольно похожи внутри себя, то стоит подумать над их
объединением в один.

### Элементы одного типа
При встрече одинаковых DOM-элементов происходит сравнение их атрибутов, измененные
атрибуты обновляются.
```jsx
<div className="before" title="stuff" />
// класс изменится с before на after, элемент останется тем же
<div className="after" title="stuff" />
```
Обновляя style, React также знает, что нужно обновлять только изменившиеся свойства.
Например:
```jsx
<div style={{color: 'red', fontWeight: 'bold'}} />
// изменит только свойство цвета при обновлении
<div style={{color: 'green', fontWeight: 'bold'}} />
```
После сравнения полей узла React рекурсивно проходит дочерние узлы.

Обновление компонентов происходит аналогичным образом, только вместо атрибутов
обновляются пропы, сохраняются инстансы компонентов и их состояния.

### Рекурсия по дочерним элементам
По умолчанию React проходит дочерние узлы одновременно и при нахождении различий
обновляет (добавляет) не совпавший элемент.
Добавление элемента в конец списка будет эффективным:
```jsx
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>
// Добавился в конец остальные элементы не поменялись.
<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>
```

А добавление элемента в начало будет весьма неэффективным, при сравнении каждого
дочернего узла будет найдено различие и каждый элемент будет обновлен.
```jsx
<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>

<ul>
  <!-- был Санкт-Петербург -->
  <li>Ростов-на-Дону</li>
  <!-- была Москва -->
  <li>Санкт-Петербург</li>
  <!-- добавился новый -->
  <li>Москва</li>
</ul>
```

Обновление 3 элементов не такая большая проблема, но если в списке 1000 пунктов, а
то и более, то будут серьезные проблемы с производительностью.

### Ключи
Для решения этой проблемы React поддерживает атрибут key.
Когда у дочерних элементов есть ключи, React использует их,
чтобы сопоставить потомков исходного дерева с потомками последующего дерева.
Например, если добавить key к неэффективному примеру выше,
преобразование дерева станет эффективным:
```jsx
<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>
```
Теперь React знает, что элемент с ключом '2014' — новый,
а элементы с ключами '2015' и '2016' только что переместились.

**Ключи должны быть неизменны для одной записи между разными рендерами**.
Если ключи изменятся, то произойдут непредсказуемые мутации при обновлении.
Могут смешаться состояния и пропы, несовместимые с компонентами.

Обычно ключи основываются на данных полученных с сервера, в крайнем случае данные
можно прохешировать и получить уникальный ключ для каждой записи.

### React Fiber
В React начиная с 16 версии появился механизм React Fiber - это внутренняя
реализация React для работы с DOM-деревом.
По своей сути является дополнением VDOM, которое добавляет виртуальный стек
при работе с React.

Начиная с этой версии React решает за пользователей фреймворка как спланировать
выполнение задач связанных с рендерингом компонентов.
Рендеринг компонентов разбивается на небольшие кусочки, так чтобы не блокировать
взаимодействие пользователя.

Виртуальный стек позволяет приоритизировать выполнение задач, приостановить выполнение
или выбросить задачу из стека, если она потеряла актуальность.
Благодаря этому рендеринг компонентов стал асинхронным и неблокирующим, а
изменения к DOM-дереву применяются синхронно.

React Fiber основывается на всем что было описано, для более глубокого
изучения можно прочитать [статью]([https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react])
или посмотреть [видео-обзор]([https://www.youtube.com/watch?v=aV1271hd9ew])

[tree_diff]: ./4.%20Virtual%20DOM/tree_diff.png
