# Рендеринг JSX

Ранее мы рассмотрели как выглядит основной синтаксис JSX.
Он описывает то, что вы хотите увидеть в браузере.
При рендере React преобразовывает JSX в легковесные аналоги DOM-элементов,
а ReactDOM обновляет DOM, чтобы он соответствовал полученным React-элементам.

> Элементы React — аналоги HTML-элементов в среде React.

Чтобы отрендерить JSX необходимо чтобы в нашем HTML-файле был «корневой» узел DOM, так как
ReactDOM будет управлять его содержимым. Например: ```<div id="root"></div>```.

Обычно в приложениях, написанных полностью на React, есть только один корневой элемент.
При встраивании React в существующее приложение вы можете рендерить во столько независимых
корневых элементов, во сколько посчитаете нужным.

Для рендеринга React-элемента в корневой узел DOM вызовите ```ReactDOM.render()```
с React-элементом и корневым DOM узлом в качестве аргументов:

```jsx 
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById('root'));
```

## Обновление JSX

Элементы React иммутабельны.
После создания элемента нельзя изменить его потомков или атрибуты.
Элемент похож на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.

Пока что, мы знаем только один способ обновить интерфейс —
это создать новый элемент и передать его в ```ReactDOM.render()```.

Рассмотрим пример с часами:

```jsx
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);
```

В этом примере ```ReactDOM.render()``` вызывается каждую секунду с помощью колбэка setInterval().

**React обновляет только то, что необходимо**

React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только
минимально необходимые изменения.

![alt-Обновление DOM][dom_update]

## Компоненты и пропсы

Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности.
Их можно складывать вместе и использовать несколько раз.

Во многом компоненты ведут себя как обычные функции JavaScript.
Они принимают произвольные входные данные (так называемые «пропсы») и возвращают
React-элементы, описывающие, что мы хотим увидеть на экране.

### Функциональный компонент

Проще всего объявить React-компонент как функцию:
```jsx
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}
```
Эта функция — компонент, потому что она получает данные в одном объекте («пропсы»)
в качестве параметра и возвращает React-элемент.
Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.

### Классовый компонент

Если нам необходимо более сложное взаимодействие, чем просто шаблонный компонент, то необходимо
использовать класс. Классовый компонент описывается так:
```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```

### Рендеринг компонента
Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в
один объект и передаёт их нашему компоненту. Этот объект называется «пропсы» (props).

Например, этот компонент выведет «Привет, Алиса» на страницу:
```jsx
const element = <Welcome name="Алиса" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

Давайте разберём, что именно здесь происходит:
  1. Мы передаём React-элемент ```<Welcome name="Алиса" />``` в ```ReactDOM.render()```.
  1. React вызывает наш компонент ```Welcome``` с пропсами ```{name: 'Алиса'}```.
  1. Наш компонент Welcome возвращает элемент ```<h1>Привет, Алиса</h1>``` в качестве результата.
  1. React DOM делает минимальные изменения в DOM, чтобы получилось ```<h1>Привет, Алиса</h1>```.

### Пропсы можно только читать

Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того,
функциональный он или классовый.

Возьмём для примера функцию sum:

```js
function sum(a, b) {
  return a + b;
}
```

Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо
возвращают один и тот же результат для одинаковых аргументов.

А вот пример нечистой функции — она записывает данные в свои же аргументы:

```js
function withdraw(account, amount) {
  account.total -= amount;
}
```

React достаточно гибкий, но есть одно правило, которое нельзя нарушать:

***React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.***

### Композиция компонентов

Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве.
Это позволяет нам использовать одну и ту же абстракцию — компоненты — на любом уровне
нашего приложения.
Неважно, пишем ли мы кнопку, форму или целый экран: все они, как правило, представляют
собой компоненты в React-приложениях.

Например, компонент App может отрендерить компонент Welcome несколько раз:

```jsx
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Алиса" />
      <Welcome name="Базилио" />
      <Welcome name="Буратино" />
    </div>
  );
}

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
```

В приложениях, написанных на React с нуля, как правило, есть один компонент ```App```,
который находится на самом верху.

В случае, если вы переписываете существующее приложение на React,
имеет смысл начать работу с маленького компонента типа ```Button``` и
постепенно двигаться «вверх» по иерархии.

## Состояние и жизненный цикл компонента

Мы разобрались как описать и отрендерить компонент, а так же, как его обновить,
но обновление компонента извне не самая лучшая идея.
Обычно логика обновления инкапсулируется внутри него.

В React это делается с помощью состояния и методов жизненного цикла.
>**Состояние** — объект внутри компонента, содержащий данные необходимые для его рендера.

Объект состояния может изменяться самим компонентом в отличие от пропсов, в него можно
записать результаты удаленного вызова или результаты внутренних вычислений.

### Преобразуем верстку в компонент
Покажем на примере часов, как инкапсулировать логику в компоненте.

Для начала, создадим компонент, показывающий время:

```jsx
function Clock(props) {
  return (
    <div>
      <h1>Привет, мир!</h1>
      <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>
    </div>
  );
}

function tick() {
  ReactDOM.render(
    <Clock date={new Date()} />,
    document.getElementById('root')
  );
}

setInterval(tick, 1000);
```

Так мы все еще обновляем DOM-дерево извне, а в идеале это должна быть зона ответственности
компонента и для его включения нужно было всего лишь:

```jsx
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

### Переходим на ES6-класс
Чтобы начать работать с состоянием необходимо преобразовать функциональный компонент в
классовый.
Для этого произведем следующие шаги:
  1. Создаём ES6-класс с таким же именем, указываем React.Component в качестве родительского
     класса
  1. Добавим в класс пустой метод ```render()```
  1. Перенесём тело функции в метод ```render()```
  1. Заменим ```props``` на ```this.props``` в теле ```render()```
  1. Удалим оставшееся пустое объявление функции

```jsx
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

### Используем состояние
Переместим ```date``` из пропсов в состояние в три этапа:
  1. Заменим ```this.props.date``` на ```this.state.date``` в методе ```render()```:
```jsx
class Clock extends React.Component {
    render() {
        return (
            <div>
                <h1>Привет, мир!</h1>
                <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
            </div>
        );
    }
}
```
  2. Добавим конструктор класса, в котором укажем начальное состояние в переменной 
     ```this.state```:
```jsx
class Clock extends React.Component {
    constructor(props) {
        super(props);
        this.state = {date: new Date()};
    }

    render() {
        return (
            <div>
                <h1>Привет, мир!</h1>
                <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
            </div>
        );
    }
}
```     

Обратите внимание, что мы передаём props базовому (родительскому) конструктору:
```jsx
constructor(props) {
    super(props);
    this.state = {date: new Date()};
}
```
Классовые компоненты всегда должны вызывать базовый конструктор с аргументом ```props```.

  3. Удалим проп ```date``` из элемента ```<Clock />```:
```jsx
ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

Мы получили компонент, который использует состояние, но не меняет его.
Для изменения состояния воспользуемся методами жизненного цикла компонента.

### Применим методы жизненного цикла
Первоначальный рендеринг компонента в DOM называется «монтирование» (mounting).
Нам нужно устанавливать таймер всякий раз, когда это происходит.

Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting).
Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».
Объявим специальные методы, которые компонент будет вызывать при монтировании и размонтировании:

```jsx
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
  }

  componentWillUnmount() {
  }

  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

Эти методы называются «методами жизненного цикла» (lifecycle methods).

Метод componentDidMount() запускается после того, как компонент отрендерился в DOM
— здесь мы и установим таймер:

```jsx
componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }
```

Обратите внимание, что мы сохраняем ID таймера в ```this``` (```this.timerID```).
Поля this.props и this.state в классах — особенные, и их устанавливает сам React.
Поля не влияющие на рендеринг необходимо записывать на сам компонент.

Теперь нам осталось сбросить таймер в методе жизненного цикла componentWillUnmount():
```jsx
componentWillUnmount() {
    clearInterval(this.timerID);
}
```

Наконец, реализуем метод ```tick()```.
Он запускается таймером каждую секунду и вызывает ```this.setState()```.

```this.setState()``` планирует обновление внутреннего состояния компонента.
Получим компонент:
```jsx
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

Теперь часы обновляются каждую секунду.

#### Как правильно использовать состояние
Важно знать три детали о правильном применении setState():
  1. **Не меняйте состояние напрямую**, можно только инициализировать состяояние в конструкторе.
     ```jsx
     // Неправильно
     this.state.comment = 'Привет';
      
     // Правильно
     constructor() { 
       this.state = { comment: 'Привет' };  
     }
   
     // Правильно
     this.setState({comment: 'Привет'})
     ```
  1. **Props и state могут обновляться асинхронно**.
     
     React может сгруппировать несколько вызовов `setState()` в одно обновление 
     для улучшения производительности.
     Поскольку `this.props` и `this.state` могут обновляться асинхронно,
     вы не должны полагаться на их текущее значение для вычисления следующего состояния.
     ```jsx
     // Неправильно
     this.setState({
       counter: this.state.counter + this.props.increment,
     });
      
     // Правильно
     this.setState((state, props) => ({
       counter: state.counter + props.increment
     }));
     ```
  1. **Обновления состояния объединяются**

     Когда мы вызываем `setState()`, React объединит аргумент (новое состояние)
     c текущим состоянием.
     Например, состояние может состоять из нескольких независимых полей:
     ```jsx
     constructor(props) {
         super(props);
         this.state = {
           posts: [],
           comments: []
         };
     }
     ```
     Их можно обновлять по отдельности с помощью отдельных вызовов `setState()`:
     ```jsx
     componentDidMount() {
         fetchPosts().then(response => {
           this.setState({
             posts: response.posts
           });
         });
     
         fetchComments().then(response => {
           this.setState({
             comments: response.comments
           });
         });
     }
     ```
     Состояния объединяются поверхностно, поэтому вызов `this.setState({comments})`
     оставляет `this.state.posts` нетронутым, но полностью заменяет `this.state.comments`.

#### Как работает компонент
Давайте рассмотрим наше решение и разберём порядок, в котором вызываются методы:

  1. Когда мы передаём ```<Clock />``` в ```ReactDOM.render()```, React вызывает
     конструктор компонента. ```Clock``` должен отображать текущее время, поэтому мы задаём
     начальное состояние ```this.state``` объектом с текущим временем.
  1. React вызывает метод ```render()``` компонента ```Clock```.
     Таким образом React узнаёт, что отобразить на экране.
     Далее React обновляет DOM так, чтобы он соответствовал выводу рендера ```Clock```.
  1. Как только вывод рендера ```Clock``` вставлен в DOM, React вызывает метод жизненного
     цикла ```componentDidMount()```.
     Внутри него компонент ```Clock``` указывает браузеру установить таймер,
     который будет вызывать ```tick()``` раз в секунду.
  1. Таймер вызывает ```tick()``` ежесекундно.
     Внутри ```tick()``` мы просим React обновить состояние компонента,
     вызывая ```setState()``` с текущим временем.
     React реагирует на изменение состояния и снова запускает ```render()```.
     На этот раз ```this.state.date``` в методе ```render()``` содержит новое значение,
     поэтому React заменит DOM.
     Таким образом компонент ```Clock``` каждую секунду обновляет UI.
  1. Если компонент ```Clock``` когда-либо удалится из DOM, React вызовет метод
     жизненного цикла ```componentWillUnmount()``` и сбросит таймер.

![alt-схема работы часов][clock_scheme]

### Подробнее про методы жизненного цикла
Существует большое количество методов компонента, предоставляемых библиотекой React.
В данном разделе будут рассмотрены основные, более подробно рассмотреть тему можно 
в [официальной статье]([detailed_article]). 

#### constructor
Необязательный метод жизненного цикла, необходим для двух целей:
  * Установить начальное состояние компонента в ```this.state```
  * Привязать контекст обработчиков к компоненту ```this.handleClick = this.handleClick.bind(this)``` 

> Если ни то, ни другое вам не нужно, то и конструктор объявлять нет необходимости 
```jsx
constructor(props) {
  super(props);
  // Не вызывайте здесь this.setState()!
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}
```

> Не копируйте пропсы в состояние! Это распространённая ошибка:
> ```jsx
> constructor(props) {
>   super(props);
>   // Не делайте этого!
>   this.state = { color: props.color };
> }
> ```
> Используйте данный подход, если вы намеренно хотите игнорировать обновления пропсов.
> Например, как значение пропа по умолчанию.

#### render()
Единственный обязательный метод в классовом компоненте.
При вызове он проверяет ```this.props``` и ```this.state``` и возвращает один из следующих вариантов:
  * **Элемент React**. Обычно создаётся с помощью JSX.
    Указывает React, что рендерить: DOM-узел или пользовательский компонент.
    Например, ```<div />``` или ```<MyComponent />```.
  * **Массивы и фрагменты**. Возвращает несколько элементов из render().
  * **Строки и числа**. Рендерит текстовые DOM-узлы.
  * **Booleans или null**. Ничего не рендерит.

Функция render() должна быть чистой.
Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же
результат, не взаимодействует напрямую с браузером.

#### componentDidMount()
```componentDidMount()``` вызывается сразу после монтирования (то есть, вставки компонента в DOM).
В этом методе должны происходить действия, которые требуют наличия DOM-узлов.
Это хорошее место для создания сетевых запросов.
Этот метод подходит для настройки подписок.
Но не забудьте отписаться от них в componentWillUnmount().

**Вы можете сразу вызвать setState() в componentDidMount()**.
Это вызовет дополнительный рендер перед тем, как браузер обновит экран.
Гарантируется, что пользователь не увидит промежуточное состояние,
даже если ```render()``` будет вызываться дважды.

Используйте этот подход с осторожностью, он **может вызвать проблемы с производительностью**.
В большинстве случаев начальное состояние лучше объявить в ```constructor()```.
Однако, это может быть необходимо для случаев, когда нужно измерить размер или положение
DOM-узла, на основе которого происходит рендер.
Например, для модальных окон или всплывающих подсказок.

#### componentDidUpdate()
```componentDidUpdate(prevProps, prevState)```
```componentDidUpdate()``` вызывается сразу после обновления.
Не вызывается при первом рендере.

Метод позволяет работать с DOM при обновлении компонента.
Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании
результата сравнения текущих пропсов с предыдущими.
Если пропсы не изменились, новый запрос может и не требоваться.

```jsx
componentDidUpdate(prevProps) {
  // Популярный пример (не забудьте сравнить пропсы):
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```

В ```componentDidUpdate()``` можно вызывать ```setState()```,
однако его необходимо обернуть в условие, как в примере выше, 
чтобы не возник бесконечный цикл.
Вызов ```setState()``` влечет за собой дополнительный рендер,
который незаметен для пользователя, но может повлиять на производительность компонента.

#### componentWillUnmount()
```componentWillUnmount()``` вызывается непосредственно перед размонтированием и удалением
компонента.
В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок,
созданных в componentDidMount().

**Не используйте ```setState()``` в ```componentWillUnmount()```**,
так как компонент никогда не рендерится повторно.
После того, как экземпляр компонента будет размонтирован,
он никогда не будет примонтирован снова.

Схема жизни компонента показана на следующей схеме:
![alt-Схема жизни компонента][component_lifecycle]

### Однонаправленный поток данных
В иерархии компонентов ни родительский, ни дочерние компоненты не знают,
задано ли состояние другого компонента.
Также не важно, как был создан определённый компонент — с помощью функции
или с помощью класса.

Состояние часто называют «локальным», «внутренним» или инкапсулированным.
Оно доступно только для самого компонента и скрыто от других.

Компонент может передать своё состояние вниз по дереву в виде пропсов
дочерних компонентов:

```jsx
<FormattedDate date={this.state.date} />
```

Компонент `FormattedDate` получает `date` через пропсы, но он не знает,
откуда они взялись изначально — из состояния `Clock`, пропсов `Clock` или
просто JavaScript-выражения:

```jsx
function FormattedDate(props) {
  return <h2>Сейчас {props.date.toLocaleTimeString()}.</h2>;
}
```

Это, в общем, называется «нисходящим» («top-down») или «однонаправленным»
(«unidirectional») потоком данных.
Состояние всегда принадлежит определённому компоненту, а любые производные
этого состояния могут влиять только на компоненты, находящиеся «ниже»
в дереве компонентов.

Если представить иерархию компонентов как водопад пропсов, то состояние
каждого компонента похоже на дополнительный источник, который сливается
с водопадом в произвольной точке, но также течёт вниз.

В React-приложениях, имеет ли компонент состояние или нет — это внутренняя
деталь реализации компонента, которая может меняться со временем.
Можно использовать компоненты без состояния в компонентах с состоянием,
и наоборот.

[dom_update]: ./3.%20Render/dom_update.gif
[clock_scheme]: ./3.%20Render/clock_scheme.png
[detailed_article]: https://ru.reactjs.org/docs/react-component.html
[component_lifecycle]: ./3.%20Render/component_lifecycle.png
