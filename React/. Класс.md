### Классовый компонент

Если нам необходимо более сложное взаимодействие, чем просто шаблонный компонент, то необходимо
использовать класс. Классовый компонент описывается так:
```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```

### Переходим на ES6-класс
Чтобы начать работать с состоянием необходимо преобразовать функциональный компонент в
классовый.
Для этого произведем следующие шаги:
1. Создаём ES6-класс с таким же именем, указываем React.Component в качестве родительского
   класса
1. Добавим в класс пустой метод ```render()```
1. Перенесём тело функции в метод ```render()```
1. Заменим ```props``` на ```this.props``` в теле ```render()```
1. Удалим оставшееся пустое объявление функции

```jsx
class Clock extends React.Component {
  render() {
    return (
      <div>
        <h1>Привет, мир!</h1>
        <h2>Сейчас {this.props.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

### Подробнее про методы жизненного цикла
Существует большое количество методов компонента, предоставляемых библиотекой React.
В данном разделе будут рассмотрены основные, более подробно рассмотреть тему можно
в [официальной статье]([detailed_article]).

#### constructor
Необязательный метод жизненного цикла, необходим для двух целей:
* Установить начальное состояние компонента в ```this.state```
* Привязать контекст обработчиков к компоненту ```this.handleClick = this.handleClick.bind(this)```

> Если ни то, ни другое вам не нужно, то и конструктор объявлять нет необходимости
```jsx
constructor(props) {
  super(props);
  // Не вызывайте здесь this.setState()!
  this.state = { counter: 0 };
  this.handleClick = this.handleClick.bind(this);
}
```

> Не копируйте пропсы в состояние! Это распространённая ошибка:
> ```jsx
> constructor(props) {
>   super(props);
>   // Не делайте этого!
>   this.state = { color: props.color };
> }
> ```
> Используйте данный подход, если вы намеренно хотите игнорировать обновления пропсов.
> Например, как значение пропа по умолчанию.

#### render()
Единственный обязательный метод в классовом компоненте.
При вызове он проверяет ```this.props``` и ```this.state``` и возвращает один из следующих вариантов:
* **Элемент React**. Обычно создаётся с помощью JSX.
  Указывает React, что рендерить: DOM-узел или пользовательский компонент.
  Например, ```<div />``` или ```<MyComponent />```.
* **Массивы и фрагменты**. Возвращает несколько элементов из render().
* **Строки и числа**. Рендерит текстовые DOM-узлы.
* **Booleans или null**. Ничего не рендерит.

Функция render() должна быть чистой.
Это означает, что она не изменяет состояние компонента, всегда возвращает один и тот же
результат, не взаимодействует напрямую с браузером.

#### componentDidMount()
```componentDidMount()``` вызывается сразу после монтирования (то есть, вставки компонента в DOM).
В этом методе должны происходить действия, которые требуют наличия DOM-узлов.
Это хорошее место для создания сетевых запросов.
Этот метод подходит для настройки подписок.
Но не забудьте отписаться от них в componentWillUnmount().

**Вы можете сразу вызвать setState() в componentDidMount()**.
Это вызовет дополнительный рендер перед тем, как браузер обновит экран.
Гарантируется, что пользователь не увидит промежуточное состояние,
даже если ```render()``` будет вызываться дважды.

Используйте этот подход с осторожностью, он **может вызвать проблемы с производительностью**.
В большинстве случаев начальное состояние лучше объявить в ```constructor()```.
Однако, это может быть необходимо для случаев, когда нужно измерить размер или положение
DOM-узла, на основе которого происходит рендер.
Например, для модальных окон или всплывающих подсказок.

#### componentDidUpdate()
```componentDidUpdate(prevProps, prevState)```
```componentDidUpdate()``` вызывается сразу после обновления.
Не вызывается при первом рендере.

Метод позволяет работать с DOM при обновлении компонента.
Также он подходит для выполнения таких сетевых запросов, которые выполняются на основании
результата сравнения текущих пропсов с предыдущими.
Если пропсы не изменились, новый запрос может и не требоваться.

```jsx
componentDidUpdate(prevProps) {
  // Популярный пример (не забудьте сравнить пропсы):
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```

В ```componentDidUpdate()``` можно вызывать ```setState()```,
однако его необходимо обернуть в условие, как в примере выше,
чтобы не возник бесконечный цикл.
Вызов ```setState()``` влечет за собой дополнительный рендер,
который незаметен для пользователя, но может повлиять на производительность компонента.

#### componentWillUnmount()
```componentWillUnmount()``` вызывается непосредственно перед размонтированием и удалением
компонента.
В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок,
созданных в componentDidMount().

**Не используйте ```setState()``` в ```componentWillUnmount()```**,
так как компонент никогда не рендерится повторно.
После того, как экземпляр компонента будет размонтирован,
он никогда не будет примонтирован снова.

Схема жизни компонента показана на следующей схеме:
![alt-Схема жизни компонента][component_lifecycle]

[component_lifecycle]: ./3.%20Render/component_lifecycle.png
