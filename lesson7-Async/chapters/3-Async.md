# Откуда берется асинхронный код

Асинхронные операции возникают при взаимодействии с браузерным API (например запрос по сети или установка таймера) и мы зачастую заранее не знаем сколько времени они будут выполняться и с каким результатом завершаться.

Взглянем на этот код:

```javascript
    const start = Date.now();
    let xhr = new XMLHttpRequest();
    xhr.open('GET', '/long-response');
    xhr.onload = function() {
        if (xhr.status !== 200) {
            alert('Ошибка');
        } else {
            alert(`Выполнено за ${(Date.now() - start) / 1000} секунд`);
        }
    };
    xhr.onerror = function(err) {
        alert("Запрос не удался");
    };
```

В этом коде мы, как бы, говорим браузеру: "обратись по этому адресу и в случае успеха вызови функцию `onload`, а если выполнить запрос не получается, вызови функцию `onerror`".

Или вот еще код для примера:

```javascript
    callback = () => {
        console.log('callback');
    }
    setTimeout(callback, 2000);
```

Тут мы говорим браузеру: "запланируй вызов функции callback через 2000 милисекунд". Но через заданный промежуток времени браузер может быть занят более приоритетными задачами (выполнять перерисовку страницы или выполнять какие-то вычисления) и вызов произойдет позже, когда браузер освободится.

Есть несколько способов писать асинхронный код в JavaScript. Они будут рассмотрены в следующих главах.