# Event Loop

JavaScript осуществляет работу с асинхронным кодом при помощи Event Loop или цикла событий.

Event Loop - бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.

В упрощенном варианте работу цикла событий можно описать так:
1. Пока есть задачи выполнить их, начиная с самой старой
2. Бездействовать до появления новой задачи, а затем перейти к п.1

## Очередь задач

Все асинхронные операции отдаются на выполнение браузерному API и по выполнению обработчики результата этих операций (колбеки) помещаются в специальную очередь - очередь задач.

Эта очередь — список задач, подлежащих обработке. Каждая задача ассоциируется с некоторой функцией, которая будет вызвана, чтобы обработать эту задачу.

Когда стек полностью освобождается, самая первая задача извлекается из очереди и обрабатывается. Обработка задачи состоит в вызове ассоциированной с ней функции с параметрами, записанными в этой задаче. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов.

Обработка задачи заканчивается, когда стек снова становится пустым. Следующая задача извлекается из очереди и начинается её обработка.

## Пример

Рассмотрим работу цикла событий на примере

```javascript
    const networkRequest = () => {
        setTimeout(() => {
            console.log('Async Code');
        }, 2000);
    };

    console.log('Hello World');
    networkRequest();
    console.log('The End');
```

Когда браузер загрузит этот скрипт у него появится задача - выполнение этого скрипта. И так как в данный момент он ничем не занят, он начнет ее выполнять.

Как это будет происходить:

Когда код начал выполняться, был создан глобальный контекст выполнения и добавлен на вершину стека вызовов. Далее, на вершину стека вызовов помещается console.log('Hello World'), после выполнения он удаляется из стека.

Далее встречается вызов функции networkRequest(), он добавляется на вершину стека.

Следующей вызывается функция setTimeout() и помещается на вершину стека. Функция setTimeout() имеет 2 аргумента: 1) функция обратного вызова и 2) время в миллисекундах.

setTimeout() запускает таймер на 2 секунды в окружении web API. На этом этапе, setTimeout() завершается и удаляется из стека.

После этого, в стек добавляется console.log('The End'), выполняется и удаляется из него по завершению.

На этом п.1 из алгоритма работы цикла событий завершен и браузер приступит к выполнению п.2. Он будет ждать появления новых задач.

Через 2 секунды таймер истечет и в очередь задач будет добавлен колбек из setTimeout'а. Т.к. стек вызовов пуст, браузер снова перейдет к п.1 - начнет выполнение задач, начиная с самой старой.

console.log('Async Code') добавляется на вершину стека, выполняется и удаляется из него.

На этом моменте обратный вызов выполнен и удален из стека.

И движок JavaScript снова бездействует до появления новой задачи.

![eventloop](../resources/eventloop.gif)

Можно попробовать дугие примеры работы цикла событий с очередью макрозадач в [онлайн песочнице](http://latentflip.com/loupe/)
