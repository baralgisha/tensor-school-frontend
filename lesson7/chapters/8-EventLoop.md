# Продвинутый Event Loop

В предыдущей главе мы рассмотрели упрощенный алгорим работы цикла событий. В этом мы рассмотрим его более полно.

Алгоритм работы цикла событий:
1. Выполнить первую в очереди задачу из очереди задач (Tasks)
    * при отсутствии задач в очереди пропустить шаг
2. Выполнить первую в очереди задачу из очереди микрозадач (Microtasks)
    * делать это пока очередь не будет пуста (в процессе выполнения микро задач, очередь может пополняться)
    * при отсутствии задач в очереди пропустить шаг
3. Выполнить перерендер страницы при необходимости (Render)
4. Повторить цикл

Очередь микрозадач - очередь задач, которые нужно выполнить сразу после текущего исполняемого сценария. Сюда попадают обработчики разрешившихся [промисов](./6-Promise.md) и колбеки [MutationObserver](https://developer.mozilla.org/ru/docs/Web/API/MutationObserver).

Очередь задач - очередь задач, которые нужно выполнить после текущего исполняемого сценария, всех микрозадач и браузерного рендеринга.  Сюда попадают обработчики [setTimeout и setInterval](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous/Timeouts_and_intervals), [xhr](https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest), [fetch](https://developer.mozilla.org/ru/docs/Web/API/Fetch_API), [браузерные события](https://developer.mozilla.org/ru/docs/Web/Events).

![eventloop](../resources/eventloop2.png)

На основе этой схемы строится вся работа Event Loop.

После того как мы начали выполнять какой-либо script, в очередь Tasks ставится задача с выполнением этого скрипта. По мере выполнения этого кода, нам встречаются различные задачи, которые ставятся в соответствующие очереди. 

После того как завершается задача по выполнению скрипта (задача от Tasks), Event Loop идет к Microtasks (после задачи от Tasks Event Loop берет задачи от Microtasks). У него Event Loop берет задачи **до тех пор, пока они не закончатся**. Это значит, что если время их добавления равно времени их выполнения, то Event Loop будет бесконечно их разгребать.

Далее он идет к Render и выполняет задачи от него. Задачи от Render оптимизируются браузером и, если он посчитает, что в этом цикле не нужно ничего перерисовывать, то Event Loop просто пойдет дальше.

Далее Event Loop снова берет задачи от Tasks и просит у него **только одну, первую в очереди задачу**, передает ее в CallStack и идет дальше по циклу.

Рассмотрим пример:

```javascript
    console.log('start');

    setTimeout(() => {
        console.log('in timeout');
    }, 0);

    new Promise((resolve) => {
        console.log('in promise');
        resolve();
    }).then(() => {
        console.log('in then 1');
    }).then(() => {
        console.log('in then 2');
    });

    console.log('end');
```

Порядок вывода сообщений в консоль будет таким:  

```javascript
    'start'
    'in promise'
    'end'
    'in then 1'
    'in then 2'
    'in timeout'
```

В начале в очередь задач будет добавлено выполнение всего скрипта.

Первый будет встречен и выполнен console.log('start').

Затем будет встречен setTimeout. Значение таймера равно нулю, так что его колбек будет сразу добавлен в очередь задач.

Затем будет встречен промис. Его конструктор выполняется синхронно, поэтому следующим мы увидим console.log('in promise').

Т.к. промис сразу разрешился, его обработчик будет добавлен в очередь микрозадач.

Затем будем встречен и выполнен console.log('end').

Выполнение задачи завершилось. Дальше Event Loop переходит к очереди микрозадач и выполняет обработчик промиса console.log('in then 1'). Т.к. из обработчика вернулся undefined, следущий обработчик будет сразу добавлен в очередь микрозадач.

Т.к. в очереди микрозадач еще есть задача, Event Loop будет выполнять ее - console.log('in then 2').

Затем очередь микрозадач опустеет и цикл событий перейдет к Render. На данном этапе перерисовки не требуются, так что цикл перейдет к очереди задач.

В очереди задач есть колбек setTimeout - console.log('in timeout'). Он будет выполнен следующим.

На этом задачи кончатся и цикл событий будет бездействовать в ожидании новых задач.

