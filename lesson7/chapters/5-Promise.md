# Решаем проблемы callback hell с помощью Promise

Promise (промис) - современный и более удобный способ организации асинхронного кода.

Promise в переводе с английского - обещание. "Обещание" выполнить одну функцию в случае успеха или другую в случае провала.

Вместо того чтобы принимать в качестве аргументов колбеки и вызывать их в нужное время, асинхронная функция может вернуть Promise.  
Дальнейшая работа с результатом будет происходить через промис, путем добавления на него обработчиков.

Promise представляет собой объект, который содержит будущее значение асинхронной операции. 

Разберемся с синтаксисом промисов и как с ним работать.

Promise имеет три состояния:

* нерешенный (в ожидании),
* решенный/resolved (завершен успешно),
* отклоненный/rejected (завершен с ошибкой).

Или в контексте "обещания":

* обещание дано, но еще не выпонено,
* обещание выполнено,
* обещание не выполнено.

Конструктор:

```javascript
    const promise = new Promise((resolve, reject) => {
        // какая-то логика, после чего вызывается resolve([result]) или reject([reason])
    });
```

Функция, переданная в конструктор new Promise, называется исполнитель. Когда Promise создаётся, она запускается автоматически и синхронно. Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.

Когда promise получает результат, должен быть вызван один из этих колбэков:

resolve([result]) — если работа завершилась успешно, с результатом result.  
reject([reason]) — если произошла ошибка, reason – объект ошибки.

До их вызова промис находится в состоянии "нерешенный".

Функции resolve и reject ожидают только один аргумент или ни одного. Все дополнительные аргументы будут проигнорированы.

После того как промис разрешился, он не может изменить свое состояние.

```javascript
    const promise1 = new Promise((resolve, reject) => {
        resolve(1);
        reject(new Error('something went wrong'));
        resolve(0);
    });
    const promise2 = new Promise((resolve, reject) => {
        reject(new Error('something went wrong'));
        resolve(1);
    });
```

![promise](../resources/promise.jpg)

Чтобы обработать результат выполнения промиса, существуют методы ***then***, ***catch***, ***finally***.

## Метод then
Добавляет обработчики завершения промиса (успешно или с ошибкой).
Синтаксис:

```javascript
    promise.then(
        onSuccess(result) { /* обработчик в случае успешного выполнения */ },
        onError(error) { /* обработчик в случае ошибки */ }
    );
```

Первый аргумент – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

## Метод catch

Метод .catch(f) – это сокращённый вариант .then(null, f). catch перехватывает все виды ошибок в промисах: будь то вызов reject() или ошибка, брошенная в обработчике при помощи throw.  
Хорошей практикой считается централизованная обработка ошибок в нижнем catch.

```javascript
    // promise.then(null, onError);
    // тоже самое
    promise.catch(onError);
```

Методы .then и .catch возвращают новый промис, выполненный со значением вызванного обработчика, или оригинальное значение, если промис не был обработан (т.е. если соответствующий обработчик не является функцией). Если мы пробросим (throw) ошибку внутри блока .catch, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик .then. 

```javascript
    promise.then((userData) => {
        // допустим мы хотим отрендерить карточку пользователя
        // по полученным с сервера данным
        // но при обработке этих данных произошла ошибка
        return prepareData(userData);
    }).catch((err) => {
        // если мы готовы к такой ошибке и знаем что с ней делать
        // мы можем ее обработать
        if (err instanceof WellKnownError) {
            return getNewData();
        } else {
            // иначе пробросим ее дальше, к ответственному за другие типы ошибок обработчику
            throw err;
        }
    }).then((preparedData) => {
        // если из .catch выше вернулись данные, мы попадем в этот обработчик .then
        renderUserCard(preparedData);
    }).catch((err) => {
        // если из .catch выше вернулись ошибка, значит произошло что-то,
        // что мы не можем "починить" и нужно сделать что-то другое,
        // например показать пользователю диалоговое окно с ошибкой
        showErrorDialog(err);
    });
```

## Метод finally

Вызов .finally(f) похож на .then(f, f). Независимо от результата выполнения промиса, вызовется функция f.

Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис.

Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.

Например:

```javascript
    promise.finally(f1).then(f2);
```

Если из обработчиков вернуть новый промис, то последующие обработчики будут ждать его разрешения. А если вернуть значение или не вернуть ничего, обработчики ничего не будут ждать и выполнятся сразу.

```javascript
    promise
        .then((userData) => {
            const pr2 = new Promise((resolve) => {
                setTimeout(resolve, 2000, 1);
            });
            return pr2;
        })
        .then((data) => {
            // этот обработчик будет ждать когда разрешиться pr2
            return data * 2;
        })
        .then((data) => {
            // этот обработчик выполнится сразу после предыдущего
            console.log(data);
        })
        
```

## Цепочка промисов
Так как then, catchи и finally возвращают промис, эти методы можно объединять в цепочку вызовов.

```javascript
    // promise.then(**).then(**).then(**) - результат возвращаемый в предыдущем обработчике передается в другой. 
    // promise всегда остается в том же состоянии и с результатом в котором разрешился
    pr = new Promise(resolve => {
        resolve(1);
    });
    pr.then(res => {
        console.log(res); //console.log(1)
        return res * 2;
    }).then(res => {
        console.log(res); //console.log(2) 
        return res * 2;
    }).then(res => {
        console.log(res); //console.log(4)
        return res * 2;
    });
    pr.then(res => {
        console.log(res); //console.log(1)
    });
```

## Статические методы класса Promise

*iterable* - перебираемый объект, который можно использовать в цикле for..of

**Promise.all(iterable)** - ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который исполнится после исполнения всех промисов в iterable. В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.

**Promise.allSettled(iterable)** - ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает промис, который исполняется когда все полученные промисы завершены (исполнены или отклонены), содержащий массив результатов исполнения полученных промисов.

**Promise.race(iterable)** - ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из .iterable.

**Promise.reject([reason])** - возвращает промис, отклонённый из-за reason.

**Promise.resolve([value])** - возвращает промис, исполненный с результатом value.

Давайте перепишем пример из предыдущей главы. Заменил loadScript на newLoadScript.

Функция newLoadScript принимает один аргумент: url - путь до файла со скриптом и возвращает промис. В случае неуспешной загрузки промис будет отклоненный с ошибкой, а в случае успеха - решенный с результатом.

```javascript
    newLoadScript('./dialog.js')
        .then(function(dialog) {
            dialog.open(config);
        })
        .catch(function(err) {
            errorHandler(err);
        });
```

Даже если бы, данные для отображения тоже нужно было бы запросить по сети, не появилось бы ада обратных вызовов.

```javascript
    newLoadScript('./usersData.js')
        .then(function(data) {
            if (data.getCount()) {
                return newLoadScript('./dialog.js');
            }
        })
        .then(function(dialog) {
            dialog.open(config);
        })
        .catch(function(err) {
            errorHandler(err);
        });
```

Или даже можно было бы выполнить загрузку скриптов паралельно

```javascript
    Promise.all([
        newLoadScript('./usersData.js'),
        newLoadScript('./dialog.js')
    ])
        .then(function([data, dialog]) {
            if (data.getCount()) {
                dialog.open(config);
            }
        })
        .catch(function(err) {
            errorHandler(err);
        });
```

Такой способ работы с асинхронностью позволяет делать вещи в естественном порядке. Сперва мы запускаем newLoadScript(source), и затем (.then) мы пишем, что делать с результатом.

В современном JavaScript сужествует способ писать код на промисах без использования обработчиков и колбеков, в синхронном стиле. О нем в следующей главе.