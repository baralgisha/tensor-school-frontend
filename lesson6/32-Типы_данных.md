# Типы данных

TypeScript является строго типизированным языком, в котором каждая переменная должна иметь определенный тип, при этом динамически изменить ранее установленный тип мы не сможем, в отличии от того же JavaSpript.

Это избавляет нас от большого количества ошибок, многие из которых мы можем выявить еще на этапе компиляции или увидеть предупреждение в редакторе кода.

В данном курсе мы расмотрим основные типы, которые используются чаще всего.

Полную информацию по типам вы можете узнать из [официальной документации](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html).

1. [Примитивы](#a1)
2. [Массивы](#a2)
3. [Функции](#a3)
4. [Any](#a4)
5. [Объекты](#a5)
6. [Псевдонимы типов](#a6)
7. [Объединение типов](#a7)
8. [Преобразование к типу](#a8)

### Примитивы {id="a1"}

Названия примитивных типов совпадают с результатом вызова `typeof `в JavaScript.

```JavaScript
const msg = 'Hello';

console.log(typeof msg) // "string"
```

Примедем пример и заодно увидим один из способов указания типа переменной в TypeScript: 

```TypeScript
let count: number = 0;
let msg: string = 'Hello';
let isChanged: boolean = false;
let key: symbol = Symbol('mykey');
let big: bigint = 10n;
```

> Если не указать тип переменной, присвоится тип, соотвествующий записанному в нее значению.

В данном примере будет выведена ошибка в консоль при компиляции:
```TypeScript
let a = '';

a = 0;

// Type 'number' is not assignable to type 'string'.
// Тип "number" не может быть назначен для типа "string".
```

Так же есть соответствующие одноименные типы для `null` и `undefined`.

> Поведение этих типов зависит от того, включена ли у вас опция `strictNullChecks`.

***`true`*** — если strictNullChecks выключен, значения, которые могут быть нулевыми или неопределенными, по-прежнему доступны в обычном режиме, а значения `null` и `undefined` могут быть присвоены свойству любого типа. 

***`false`*** — при включении `strictNullChecks`, когда значение равно `null` или `undefined`, вам нужно будет проверить эти значения перед использованием методов или свойств для этого значения.

### Массивы {id="a2"}

Для описания массивов, в которых лежат значения одного типа можно воспользоваться конструкцией `[]` или `Array<>`

```TypeScript
const names: string[] = ['Иван', 'Петр'];
const ages: Array<number> = [20, 30];

// Ошибка: Аргумент типа "number" нельзя назначить параметру типа "string"
names.push(25);

// Ошибка: Аргумент типа "string" нельзя назначить параметру типа "number"
ages.push('Hello world');
```

Если известно сколько, какого типа и на каких позициях будут лежать элементы в массиве, можно воспользоваться конструкцией `Tuple` (кортеж):

```TypeScript
const arr: [string, number] = ['Иван', 31];
```

### Функции {id="a3"}

Функции являются основным средством передачи данных в JavaScript. TypeScript позволяет указывать типы как для входных параметров, так и для возвращаемых значений функции.

Для объявления типа функции можно воспользоваться следующей конструкцией, в которой мы указываем параметры и выходные данные.

```TypeScript
let sayHi: (name: string, age: number) => string = (name, age) => {
   return `Hello, my name is ${name}, I'm ${age}`;
};

// Hello, my name is Ben, I'm 25
sayHi('Ben', 25);
```

Помимо типа у параметра мы можем указать значенеие по умолчанию.

```TypeScript
function sayHi(name: string = 'world'): void {
   console.log(`Hello, ${name}!`);
}

// "Hello, Artem!"
sayHi('Artem');

// "Hello, world"!
sayHi();
```

Если вы заметили в примере выше есть еще одна интересная «штука»: `void` тип возвращаемого значения функции.

`void` означает, что функция ничего не возвращает, т.е. `undefined`.

>Для входных параметров анонимных функций-колбэков TypeScript может определить тип автоматически.

Рассмотрим данное утверждение на простом примере:

```TypeScript
// Тут TypeScript сам определит тип элементов массива, string[]
const names = ["Alice", "Bob", "Eve"];
 
// Хотя мы не указываем тип параметра name, TypeScript сделал это автоматически
names.forEach(function (name) {
  console.log(name.toUpperCase());
});
 
// При вызове отсутствующего метода у val, TypeScript выдаст ошибку и подсказку:
// Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?
names.forEach((val) => {
  console.log(val.toUppercase());
});
```

Несмотря на то, что у параметров `name` и `val` не был описан тип, TypeScript сам определил его, исходя из типа метода `forEach` и предполагаемого типа массива.

### Any {id="a4"}

Нам может потребоваться описать тип переменных, который мы не знаем. Эти данные могут быть получены из динамического контента, например от пользователя или от сторонней библиотеки. Для того, чтобы отключить проверку типов и позволить пройти процесс компиляции, можно использовать тип `any`:

```TypeScript
let obj: any = { x: 0 };
// Ни одна из следующих строк кода не вызовет ошибок компилятора.
// Использование `any` отключает все дальнейшие проверки типов, и предполагается, что
// вы знаете среду лучше, чем TypeScript.
obj.foo();
obj();
obj.bar = 100;
obj = "hello";
```
Тип `any` будет полезен, когда вы не хотите писать сложный тип только для того, чтобы убедить TypeScript в том, что все ок.

Когда вы не указываете тип, и TypeScript не может вывести его из контекста, компилятор по умолчанию выбирает `any`.

Стоит избегать такой неопреденности и использовать данную возможность, когда это действительно необходимо.

Флаг компилятора `noImplicitAny` позволяет пометить любое неявное `any` как ошибку.

### Объекты {id="a5"}

Чтобы определить тип объекта, мы просто перечисляем его свойства и их типы.

```TypeScript
  function sayHi(name: {first: string; last: string}): void {
    console.log(`Hello, ${first} ${last}!`);
  }
```

После определения свойства, кроме последнего, ставится `;`.

Если не указать тип, он будет определен как `any`.

Для указания необазятельных свойств/параметров функции нужно после имени поставить знак `?` перед `:`.

Следующий код вызовет ошибку:

```TypeScript
function printName(name: { first: string; last?: string }): void {
    // Error - Object is possibly 'undefined'
    console.log(name.last.toUpperCase());
    // ...
}
```

Для необязательных (опциональных) параметров нужно делать проверку на `undefined`.

```TypeScript
// ...
if (name.last !== undefined) {
  console.log(name.last.toUpperCase());
}
// ...
```

... или воспользоваться альтернативой с использованием современного синтаксиса JavaScript

```TypeScript
// ...
console.log(name.last?.toUpperCase());
// ...
```

### Псевдонимы типов {id="a6"}

Объявлять типы объектов, записывая их непостредственно в аннотации, например при объявлении функции, не очень удобно. Часто возникает необходимость использовать один и тот же тип два и более раз и обращаться к нему по имени.

Для таких случаев в TypeScript есть возможность создания собственного типа через `type`.

```TypeScript
type TName = {
  first: string;
  last: string;
};

function printName(name: TName): void {
  // ...
}

type TNames = TName[];

const names: TNames = [
  {
    first: 'Ivan',
    last: 'Petrov'
  },
  {
    first: 'Petr',
    last: 'Ivanov'
  }
];

name.forEach((name, i) => {
  console.log(`${i + 1}. ${name.first} ${name.last}`);
});
```

Принято давать название таким псевдонимам с заглавной буквы "T" (TProduct, TPoint...).

Псевдонимы можно давать любому типу, не только объектам.

```TypeScript
type TId = number;
```

Одни псевдонимы могут заимствовать или расширять код других. Для этого применяется операция `&`.

```TypeScript
type TPerson = {name: string; age: number};
type TEmployee = TPerson & {company: string};
```

В данном случае псевдоним `TEmployee` расширяет псевдоним `TPerson`, добавляя к нему свойство company, которое представляет тип `string`. То есть фактически мы имеем дело с типом:

```TypeScript
type TEmployee = {name: string; age: number; company: string};
```

### Объединение типов {id="a7"}

Объединения или `union` не являются собственно типом данных, но они позволяют комбинировать или объединить другие типы. Так, с помощью объединений можно определить переменную, которая может хранить значение двух или более типов.

```TypeScript
type TId = number | string;

function printId(id: TId): void {
  console.log(`Your ID is: ${id}`);
}

// OK
printId(101);

// OK
printId("202");

// Error
// Argument of type '{ myID: number; }' is not assignable to parameter of type 'TId'.
//   Type '{ myID: number; }' is not assignable to type 'number'
printId({ myID: 22342 });
```

Чтобы определить все типы, которые должна представлять переменная, все эти типы разделяются прямой чертой: `number | string`. В данном случае переменная `id` может представлять как тип `string`, т.е. строку, так и число `number`.

Подобным образом можно использовать `union` для определения параметров функции:
```TypeScript
function printId(id: number | string) {
    console.log(`Id: ${id}`);
}
```

Тип `union` подходит для тех ситуаций, когда логика работы со всеми объединенными типами однообразна, например, как в случае выше, где значение извне встраивается в строку и выводится в консоли.

Однако логика может различаться в зависимости от переданного типа. В этом случае можно использовать проверку на тип, чтобы разграничить логику для различных типов:

```TypeScript
type TWords = string | string[];

function printSentence(words: TWords){
  if (typeof words === 'string') {
    console.log(words);
  } else {
    console.log(words.join(' '));
  }
}

printSentence(['Язык', 'программирования', 'TypeScript']);
printSentence('Язык программирования JavaScript');
```

Так же, используя объединения и псевдонимы, никто не запрещает создать такой тип:

```TypeScript
type TName = 'Ivan' | 'Petr' | 'Dmitriy' | 'Artem';
```

При объявлении константы через `const` TypeScript автоматически присвоит тип по содержимому.

```TypeScript
const MY_MANE = 'Artem';
// const myName: "Artem"
```

### Преобразование к типу {id="a8"}

Иногда у вас будут данные с типом, о котором TypeScript не знает.

Например, если вы используете `document.getElementById`, TypeScript думает, что этот метод вернет `HTMLElement`. Но вы то знаете, что по заданному идентификатору на вашей странице всегда будет `HTMLCanvasElement`.

```TypeScript
const myCanvas = document.getElementById('canvas');
myCanvas.height = 300;
```

В TypeScript `document.getElementById` возвращает объединение `HTMLElement | null`. Т.е. возвращаемое значение может представлять `null`, если соответствующий html-элемент отсутствует на веб-странице. Вследствие этого обращение к свойству myCanvas.height — к свойству объекта, который может быть `null`, содержит потенциальную ошибку. Поэтому компилятор при компиляции сгенерирует ошибку.

В этом случае можно использовать `type assertion` (преобразование к типу), чтобы указать более конкретный тип.

`Type assertion` представляет модель преобразования значения переменной к определенному типу. Обычно в некоторых ситуациях одна переменная может представлять какой-то широкий тип, например, `any` или `union`, которые по факту допускают значения различных типов. Однако при этом нам надо использовать переменную как значение строго определенного типа.

```TypeScript
const myCanvas = document.getElementById('canvas') as HTMLCanvasElement;
myCanvas.height = 300;
```

Существует еще одна форма приведения: перед значением в угловых скобках указывается тип, к которому надо выполнить приведение.

```TypeScript
const myCanvas = <HTMLCanvasElement>document.getElementById('canvas');
```